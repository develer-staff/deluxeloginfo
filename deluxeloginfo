#!/usr/bin/perl -w
#
# $Id$
# Copyright 2002, 2003, 2004 Bernardo Innocenti <bernie@develer.com>
#
# Dedicated to the memory of Gerry, an extraordinary engineer and
# a good friend.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Loosely based on KDE's loginfo.pl:
#   free of any copyright. Originally written by taj@kde.org with small changes
#   by coolo@kde.org and daniel.naber@t-online.de
#   Many improvements and fixes by dirk@kde.org
#
#
# $Log$
# Revision 2.26  2004/06/27 08:27:55  bernie
# Mark enscript code as being unused.
#
# Revision 2.25  2004/06/27 08:25:16  bernie
# Ubiquitous usage of log_output().
#
# Revision 2.24  2004/06/27 08:17:29  bernie
# Introduce OO syntax for file revisions.
#
# Revision 2.23  2004/06/24 22:26:14  bernie
# Use iso-8859-1 encoding for better compatibility with CVS logs edited with Windows frontends.
#
# Revision 2.22  2004/06/24 01:31:46  bernie
# Update Copyright info.
#
# Revision 2.21  2004/06/14 02:52:42  bernie
# Make newsgroups support more general.
#
# Revision 2.20  2004/06/01 01:10:20  bernie
# Add (experimental) newsgroups support.
#
# Revision 2.19  2004/05/31 19:48:00  bernie
# Pass 2nd parameter to log_output()
#
# Revision 2.18  2004/05/30 16:53:14  bernie
# Match '+++ ' and '--- ' rather than '+++' and '---' to avoid confusion with second order diffs.
#
# Revision 2.17  2004/05/23 15:13:01  bernie
# Collect multiple CCMAIL lines in a log message.
#
# Revision 2.16  2004/05/22 20:32:37  bernie
# CVS-SILENT: Trim changelog.
#
# Revision 2.15  2004/05/22 20:28:15  bernie
# Fold handling of CVSSILENT and CCMAIL into formtat_output().
#
# Revision 2.14  2004/05/14 19:19:16  bernie
# Fix spelling error.
#
# Revision 2.13  2004/05/12 01:18:49  bernie
# Several adjustments to use --rlog mode with --prjtab on local repositories.
#
# Revision 2.12  2004/04/13 05:53:17  bernie
# Fix for CVS problems parsing CEST time zone.
#

use strict;
use Getopt::Long;
use Pod::Usage;

my $versiontag = '$Revision$';
$versiontag =~ s/.*: (.*) .*/$1/;

# Command line options
my $opt_keeplogs;
my $opt_verbose;
my $opt_logfile = "";
my $opt_sender = "cvs\@develer.com";
my $opt_recipient = "";
my $opt_outfile = "";
my $opt_prjtab = "";
my $opt_rlog;
my $opt_stampdir = "/var/state/loginfo";
my $opt_byauthor;
my $opt_maildomain = "";
my $opt_cvsurl = "";
my $opt_bugurl = "";
my $opt_diff;
my $opt_difflimit = 0;
my $opt_cvsroot = "";
my $opt_cvsprefix = "";
my $opt_module = "";

#
# Hold a file-revision pair
#
package FileRev;

sub new($$)
{
	shift;
	bless { file => shift, rev => shift, removed => shift };
}

#
# Main program
#
package main;


sub add_to_cc(\$$)
{
	my ($cc, $email) = @_;
	$$cc .= length($$cc) ? ", $email" : "$email" if($$cc !~ /$email/);
}

# include first file in second file
sub append_file($$)
{
	local $/; # enable localized slurp mode
	open(my $in,  '<', shift) or die $!;
	open(my $out, '>>', shift) or die $!;
	print {$out} <$in>;
}

# Create empty file with specified owner
sub create_empty_file($$$)
{
	my $filename = shift;

	open(FILE, ">$filename") or die $!;
	close FILE;

	if (my $user = shift)
	{
		my (undef,undef,$uid,$gid) = getpwnam($user) or die $!;
		chown $uid, $gid, $filename;

		if (my $mode = shift)
		{
			chmod $mode, $filename;
		}
	}
}

sub bugzillate($)
{
	return if !$opt_bugurl;

	$_[0] =~ s#\#(\d{2,6})#<a href='$opt_bugurl?id=$1'>\#$1</a>#g;
}

sub send_mail(\$\$$$$$)
{
	my ($text, $html, $module, $to, $cc, $author) = @_;

	# Avoid sending empty mails
	if (!$$text)
	{
		print STDERR "Not sending empty mail.\n" if $opt_verbose;
		return;
	}

	# Build subject line
	my $subject = "CVS commit";
	$subject .= " by $author" if ($author);
	$subject .= " log" if (!$author);
	$subject .= " for $module" if ($module);
	{
		# Compute current time
		my (undef , undef, undef, $mday, $mon, $year, undef, undef, undef) = localtime;
		$year += 1900;
		$mon += 1;
		$subject .= sprintf(" (%04d-%02d-%02d)", $year, $mon, $mday);
	}
	
	my $from;
	if ($author and $opt_maildomain)
	{
		$from = "$author <$author\@$opt_maildomain>";
	}
	else
	{
		$from = "CVS logger <$opt_sender>";
	}

	my $newsgroups = "";

	# Force recipient if set
	if ($opt_recipient)
	{
		$to = $opt_recipient;
	}

	# Strip "mailto:" (the default)
	if ($to =~ /^mailto:(.+)/)
	{
		$to = $1;
	}
	# Match newsgroups
	elsif ($to =~ /^news:(.+)/)
	{
		$newsgroups = $1;
		$to = "";
	}

	if ($opt_outfile)
	{
		print STDERR "Writing mail to '$opt_outfile'...\n" if $opt_verbose;
		open (MAIL, ">>$opt_outfile") or die "Couldn't open outfile: $!";
	}
	elsif ($newsgroups)
	{
		print STDERR "Posting article in '$newsgroups'...\n" if $opt_verbose;
		open (MAIL, "|/usr/bin/inews -h") or die "Couldn't exec inews: $!";
	}
	elsif ($to)
	{
		print STDERR "Sending mail to <$to>...\n" if $opt_verbose;
		open (MAIL, "|/usr/lib/sendmail -t") or die "Couldn't exec sendmail: $!";
	}
	else
	{
		print STDERR "No recipient, discarding mail.\n" if $opt_verbose;
		open (MAIL, ">/dev/null") or die "Couldn't open /dev/null: $!";
	}

	print MAIL "From: $from\n";
	print MAIL "To: $to\n" if ($to);
	print MAIL "Cc: $cc\n" if ($cc);
	print MAIL "Newsgroups: $newsgroups\n" if ($newsgroups);
	print MAIL "Subject: $subject\n";

	print MAIL <<EOF;
MIME-Version: 1.0
Content-Type: multipart/alternative;
  boundary="Boundary-00=_R+zZ+ucfVzM1q7w"

This is a multi-part message in MIME format.

--Boundary-00=_R+zZ+ucfVzM1q7w
Content-Type: text/plain;
  charset="iso-8859-1"
Content-Disposition: inline

$$text

--
Generated by Deluxe Loginfo $versiontag by Bernardo Innocenti <bernie\@develer.com>
http://www.codewiz.org/projects/index.html#loginfo

--Boundary-00=_R+zZ+ucfVzM1q7w
Content-Type: text/html;
  charset="iso-8859-1"

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>$subject</title>
</head>
<body text='#000000' bgcolor='#ffffff'>
<table border='0' cellspacing='0' cellpadding='5' width='100%' bgcolor='#eeeeee'>
$$html
</table>
<p>
--<br>
<small>Generated by <a href="http://www.codewiz.org/projects/index.html#loginfo">Deluxe Loginfo</a> $versiontag by Bernardo Innocenti &lt;bernie\@develer.com&gt;</small></p>
</body>
</html>
--Boundary-00=_R+zZ+ucfVzM1q7w--
EOF

	close(MAIL);

	# Clear buffers
	$$text = "";
	$$html = "";
}

sub dodiff($$$$)
{
	my ($module, $file, $r1, $r2) = @_;
	my $diff = "";
	my $cnt = 0;
	my $copts = "";

	# Avoid diffs for files added or removed from CVS
	#return "" if (($r1 eq "NONE") or ($r2 eq "NONE"));

	# Avoid diffs for files removed from CVS
	return "" if ($r2 eq "NONE");

	# Workaround for first revion of added files (does only work with rdiff!)
	$r1 = "1.0" if ($r1 eq "NONE");

	# Regex to match source files (doesn't work with cvs rdiff)
	#my $srcfile = '\.(cpp|cc|cxx|C|c\+\+|c|l|y|h|h|hh|hxx|hpp|h\+\+|pl|jsp|java|py|sh)$';
	#$copts = "dpbB" if ($file =~ /$srcfile/);

	my $cvsroot = $opt_cvsroot;
	$cvsroot .= "/$module" if $module;

	print STDERR "+ cvs -Qfn -d$cvsroot rdiff -kk -u$copts -r$r1 -r$r2 $file\n" if $opt_verbose;
	open(CVS, "-|") || exec 'cvs', '-Qfn', "-d$cvsroot", 'rdiff', '-kk', "-u$copts", "-r$r1", "-r$r2", $file;

	while(<CVS>)
	{
		next if /^Index:/;
		$cnt++;

		# Truncate diff when it exceeds <difflimit>
		# or if the size grows over <difflimit> full lines of 80 characters.
		if ($opt_difflimit and
			(($cnt > $opt_difflimit) or (length($diff) > $opt_difflimit * 80)))
		{
			# Limit exceeded: discard further input and exit
			$diff .= "*** SIZE LIMIT EXCEEDED - DIFF TRUNCATED ***\n";
			while (<CVS>) {}
			last;
		}
		$diff .= $_;
	}
	close(CVS);
	$diff .= "\n" if (length($diff));

	return $diff;
}

sub diff2html($)
{
	my $out = "<pre>\n";

	foreach (split /\n/, shift)
	{
		# Remove trailing \n
		chomp;

		# Replace HTML reserved chars with entities
		s/&/&amp;/g;
		s/</&lt;/g;
		s/>/&gt;/g;

		# Mark leading whitespace at EOL
		s/([^ ])(\s+)$/$1<span style="background-color: #FF0000">$2<\/span>/;

		# Mark hidden whitespace before TABs
		s/([^ ])( +)\t/$1<span style="background-color: #FF0000">$2<\/span>\t/;

		# Colorize Diff
		if (/^(--- |\+\+\+ |diff)/)
		{
			$out .= "<font color=\"#006600\">$_</font>\n";
		}
		elsif (/^\+/)
		{
			$out .= "<font color=\"#000088\">$_</font>\n";
		}
		elsif (/^-/)
		{
			$out .= "<font color=\"#880000\">$_</font>\n";
		}
		elsif (/^@@/)
		{
			$out .= "<font color=\"#997700\">$_</font>\n";
		}
		elsif (/^\*\*\*/)
		{
			$out .= "<font color=\"#FF0000\">$_</font>\n";
		}
		else
		{
			$out .= "$_\n";
		}
	}
	return $out;

### BEGIN: EXPERIMENTAL/UNUSED CODE ###
	# Fork
	my $pid = open (ENSCRIPT_OUTPUT, "-|");
	die ("can't fork") unless defined($pid);
	if (!$pid)
	{
		# In child: pass text diff to enscript and die
		open (ENSCRIPT_INPUT, "|-") || exec 'enscript', '--color', '-Whtml', '-Ediffu', '-o', '-', '-';
		print ENSCRIPT_INPUT shift;
		exit 0;
	}
	else
	{
		# In parent: collect enscript output
		my $out = "";
		while(<ENSCRIPT_OUTPUT>)
		{
			$out .= $_ if (/^<PRE>/ .. /<\/PRE>/)
		}
		return $out;
	}
### END: EXPERIMENTAL/UNUSED CODE ###
}

#
# Print a message (arg 1) followed by an optional multi-line preformatted block (arg 2)
#
sub log_output
{
	if ($opt_verbose)
	{
		my ($msg, $text) = @_;
		print STDERR "  $msg";
		print STDERR ":" if $text;
		print STDERR "\n";
		if ($text)
		{
			foreach (split '\n', $text) { print "    $_\n"; }
		}
	}
}

sub format_output($$$$$\$)
{
	my ($author, $text, $log, $module, $tagname, $ccrecipients) = @_;
	my ($fmtText, $fmtHtml, $cc);
	my $diff = "";

	log_output("Processing commit by $author", $text);

	# Do nothing for empty file lists
	if (length($text) == 0)
	{
		log_output("Skipping empty log entry", "");
		return ("", "");
	}

	if ($log =~ /CVS.?SILENT/)
	{
		# Ignore this commit and reset silent status
		log_output("Ignoring commit by $author", $log);
		return ("", "");
	}

	foreach (split '\n', $log)
	{
		if (/^CCMAIL:\s*(.*)\s*$/)
		{
			add_to_cc($ccrecipients, $1);
		}
	}

	# sort the list of affected files to make it look cooler
	my @outlist = sort (split /^/, $text);

	$fmtHtml .= "<tr><td colspan='3' bgcolor='#dddddd'><font color='#bb2222'><strong>$author</strong></font>";
	$fmtHtml .= " <font color='#225522'><em>(on branch $tagname)</em></font>" if ($tagname ne "HEAD");
	$fmtHtml .= "</td></tr>\n";

	$fmtText .= "$author";
	$fmtText .= " (on branch $tagname)" if ($tagname ne "HEAD");
	$fmtText .= ":\n";

	$fmtText .= "$log\n";
	bugzillate($log);
	$fmtHtml .= "<tr><td colspan='3' bgcolor='#dddddd'><pre>$log</pre></td></tr>\n";

	foreach my $o (@outlist)
	{
		chop $o;
		my ($file, $r1, $r2) = split/\t/, $o;

		# Guess CVS operation from revisions pair
		my $state = 'M';
		$state = 'R' if ($r2 eq "NONE");
		$state = 'A' if ($r1 eq "NONE");

		# Find out a "good" revision to link to
		my $rev = $r2;
		$rev = $r1 if ($r2 eq "NONE");

		$fmtText .= sprintf("$state %6s  $file\n", $rev);

		my $statelink = $state;
		if ($opt_cvsurl)
		{
			# Prepend a slash to the module name if needed, define to an empty string otherwise
			my $module_path = "";
			$module_path = "/$module" if $module;

			if($state eq 'M')
			{
				$statelink = "<a href=\"$opt_cvsurl$module_path/$file.diff?r1=text&tr1=$r1&r2=text&tr2=$r2&diff_format=h\">$state</a>";
			}
			elsif($state eq 'A')
			{
				$statelink = "<a href=\"$opt_cvsurl$module_path/$file?rev=$r2&content-type=text/vnd.viewcvs-markup\">$state</a>";
			}
			elsif($state eq 'R')
			{
				$statelink = "<a href=\"$opt_cvsurl$module_path/$file?rev=$r1&content-type=text/vnd.viewcvs-markup\">$state</a>";
			}
		}

		$diff .= dodiff($module, $file, $r1, $r2) if ($opt_diff);

		$fmtHtml .= "<tr><td>$statelink</td><td>$rev</td><td>$file</td></tr>\n";
	}

	# Put some spacing between the file list and the diff
	$fmtText .= "\n";

	if (length($diff))
	{
		$fmtText .= $diff;
		$fmtText .= "\n";

		$fmtHtml .= "<tr><td colspan='3' bgcolor='#ffffff'>" . diff2html($diff) . "</td></tr>";
	}

	# Some spacing
	$fmtHtml .= "<tr><td colspan='3' bgcolor='#ffffff'><p>&nbsp;</p></td></tr>\n";

	return ($fmtText, $fmtHtml);
}

#
# Process commitlog files
#
sub dolog_commitlog($$$)
{
	my ($module, $commitlog, $recipient) = @_;

	# initialize with the default values
	my $fmtText = "";
	my $fmtHtml = "";
	my $tagname = "HEAD";
	my $ccrecipients = "";
	my $juststarted = 1;
	my $beforelogmsg = 1;
	my $directory = "";
	my $author = "";
	my $outtext = "";
	my $logmessage = "";
	my $prev_author = "";
	my $prev_outtext = "";
	my $prev_logmessage = "";

	open COMMITLOG, "< $commitlog" or die "couldn't open '$commitlog': $!\n";

	while(<COMMITLOG>)
	{
		if ($juststarted)
		{
			next if /^\s*$/;
			$juststarted = 0;
			chop;
			if(/^(\S*) (.*)$/)
			{
				$directory = $1;
				$_ = $2;
			}

			# "directory - New Directory" ?
			# "directory - Import sources" ?
			if(/^- /) {
				#FIXME: $silentcommit = 1 if(/^- New/);
				next;
			}
			my @files = ();
			while(/^([^,]+,(?:NONE|[\d\.]+),(?:NONE|[\d\.]+)) ?(.*)/)
			{
				push @files, $1;
				$_ = $2;
			}
			foreach my $f (@files)
			{
				next if (!length($f));
				my ($file,$r1,$r2) = $f =~ /(.+),(.+),(.+)/;
				my $relfile = "$directory/$file";
				$outtext .= "$relfile\t$r1\t$r2\n";
			}
		}
		elsif ($beforelogmsg)
		{
			next if (/^Update of /);
			next if (/^In directory /);

			if (/^Author: \s*(\S+)/) { $author = $1;      }
			elsif (/^\s*Tag: (\S+)/) { $tagname = $1;     }
			elsif (/^Log Message:/)  { $beforelogmsg = 0; }
		}
		else
		{
			if (/^---END---$/)
			{
				while (chomp $logmessage) {}

				if (($prev_logmessage eq $logmessage) && ($prev_author eq $author))
				{
					# Append current output to previous output
					log_output("Merging commit by $author", $outtext);
					$prev_outtext .= $outtext;
				}
				else
				{
					# Process previous output
					my @out = format_output($prev_author, $prev_outtext, $prev_logmessage, $module, $tagname, $ccrecipients);
					$fmtText .= $out[0];
					$fmtHtml .= $out[1];

					# Save current state for later
					$prev_author = $author;
					$prev_outtext = $outtext;
					$prev_logmessage = $logmessage;
				}

				# Restart
				$directory = "";
				$logmessage = "";
				$outtext = "";
				$juststarted = 1;
				$beforelogmsg = 1;
			}
			else
			{
				# Collect log message
				$logmessage .= "\t" . $_;
			}
		}
	}

	close COMMITLOG;

	# process last output set
	my @out = format_output($prev_author, $prev_outtext, $prev_logmessage, $module, $tagname, $ccrecipients);
	$fmtText .= $out[0];
	$fmtHtml .= $out[1];

	# Send mail
	send_mail($fmtText, $fmtHtml, $module, $recipient, $ccrecipients, undef);

	# Rotate log file
	if (!$opt_keeplogs)
	{
		my $oldlog = $commitlog;
		if ($commitlog =~ /^(.*)\.new$/)
		{
			$oldlog = $1;
		}
		else
		{
			$oldlog = "$commitlog.old";
		}

		append_file($commitlog, $oldlog);
		create_empty_file($commitlog, "cvs", 0660);
	}
}

#
# Process cvs rlog output
#
sub dolog_rlog($$$)
{
	my ($module, $commitlog, $recipient) = @_;
	my $stamp;

	# Parser states:
	#  1 - parsing file header
	#  2 - parsing revision log
	#  3 - parsing revision message
	my $state = 1;

	# initialize vars with the default values
	my $file = "";
	my $rev = "";
	my $log = "";

	# A nested data structure to hold all collected log data
	my %author_logs;

	my $fmtText = "";
	my $fmtHtml = "";
	my $tagname = "HEAD";
	my $ccrecipients = "";
	my $directory = "";
	my $author = "";
	my $outtext = "";
	my $removed = 0;

	if ($commitlog)
	{
		open RLOG, "< $commitlog" or die "couldn't open '$commitlog': $!\n";
	}
	else
	{
		# Compose CVSROOT if needed
		my $cvsroot = $opt_cvsroot;
		$cvsroot .= "/$module" if $module;

		if (! -d $opt_stampdir)
		{
			print STDERR "Creating $opt_stampdir since it doesn't exist\n";
			mkdir $opt_stampdir || die "Can't create $opt_stampdir: $!\n";
		}

		# Generate stamp file name from CVSROOT
		$stamp = $cvsroot;
		$stamp =~ tr|:\/\\@.|_____|;
		$stamp .= ".stamp";
		$stamp = "$opt_stampdir/$stamp";

		# Get timestamp from file, touch it and get filestamp again
		my $dates;
		$dates = `date --rfc-2822 -r $stamp`;
		chomp $dates;
		$dates = 'yesterday' if (!$dates);
		`touch $stamp.new`; # Update stamp file
		$dates .= "<";
		$dates .= `date --rfc-2822 -r $stamp.new`;
		chomp $dates;

		print STDERR "+ cvs -Qfn -d$cvsroot rlog -N -d '$dates' ''\n" if $opt_verbose;
		open(RLOG, "-|") || exec 'cvs', '-Qfn', "-d$cvsroot", 'rlog', '-N', "-d$dates", '';
	}

	while(<RLOG>)
	{
		if ($state == 1) # parse the header
		{
			if (/^RCS file: (.*)$/)
			{
				$file = $1;
			}
			elsif (/^---/)
			{
				$state = 2;
				$author = "UNKNOWN";
				$removed = 0;
			}
		}
		elsif ($state == 2) # parse revision log
		{
			if (/^revision (.*)/)
			{
				$rev = $1;
			}
			# EXAMPLE: date: 2003/11/26 19:46:57;  author: codewiz;  state: dead;  lines: +0 -0
			elsif (/^date:[^;]*; *author: *([^;]*); *state:([^;]*);/)
			{
				$author = $1;
				$removed = ($2 =~ /dead/) ? 1 : 0;
				$state = 3;
			}
			elsif (/^===/)
			{
				$state = 1;
			}
		}
		elsif ($state == 3) # parse log message
		{
			if (/^---/ or /^===/)
			{
				$log = "*** Empty log message! ***" if !$log;

				my $filerev = FileRev->new($file, $rev, $removed);

				if (my $l = $author_logs{$author})
				{
					if (my $f = ${$l}{$log})
					{
						log_output("Append new file for $author on $file rev $rev");

						# Append new file to existing log message
						push @$f, $filerev;
					}
					else
					{
						log_output("Create new log for $author on $file rev $rev", $log);

						# Create new log message 
						${$l}{$log} = [ $filerev ];
					}
				}
				else
				{
					log_output("Create new author $author with $file rev $rev", $log);

					# Create new log message and append file/rev pair to it
					$author_logs{$author} = { $log => [ $filerev ] };
				}

				$log = "";
				$state = 2;
				$state = 1 if (/^===/);
			}
			else
			{
				# Append log line
				$log .= $_;
			}
		}
	} # end while(<>)

	close RLOG;
	die "Reading cvs rlog failed: $!" if $?;

	# Commit date for next log
	rename "$stamp.new", "$stamp" if ($stamp);

	#
	# Extract CVS directory prefix from CVSROOT string
	#
	my $cvsdir;

	if ($opt_cvsprefix)
	{
		$cvsdir = $opt_cvsprefix;
	}
	elsif ($opt_cvsroot and $opt_cvsroot =~ /^:[^:@]*:[^:@]*@[^:@]*:([^:@]+)$/)
	{
		$cvsdir = $1;
	}

	#
	# Process accumulated logs
	#
	foreach my $author (keys %author_logs)
	{
		foreach my $log (keys %{$author_logs{$author}})
		{
			my $outtext = "";
			my $filelist = @{$author_logs{$author}}{$log};

			#DEBUG
			#use Dumpvalue;
			#my $dumper = new Dumpvalue;
			#print STDERR "****BEGIN filelist ****\n";
			#$dumper->dumpValue($filelist);
			#print STDERR "**** END filelist ****\n";

			foreach my $filerev (@$filelist)
			{
				#DEBUG
				#print STDERR "**** BEGIN filerev ****\n";
				#$dumper->dumpValue($filerev);
				#print STDERR "**** END filerev ****\n";

				my ($filename, $rev, $removed) = ( $$filerev{file}, $$filerev{rev}, $$filerev{removed} );

				# Prune ,v suffix from filename
				$filename =~ s|,v$||;

				# Prune CVS repository path from filename
				$filename =~ s|^$cvsdir/|| if $cvsdir;

				# Prune Attic directory from filename
				$filename =~ s|/Attic/|/|;

				# Prune leading '/' at the beginning of the path
				$filename =~ s|^/||;

				# Remove any spurious '//' sequences from CVS
				$filename =~ s|//|/|g;

				# Get major/minor revision numbers
				my ($r1, $r2);

				# Parse revision numbers such as 1.34 or 1.1.1.23
				if ($rev =~ /^(.*)\.([0-9]+)$/)
				{
					# Guess previous revision
					$r1 = $1 . "." . ($2 - 1);
					$r2 = $rev;
				}
				else
				{
					print STDERR "*** Warning: can't parse revision '$rev'\n";
					$r1 = "NONE";
					$r2 = "NONE";
				}

				if ($removed)
				{
					$r2 = "NONE";
				}
				# Added?
				elsif ($rev =~ /1\.1$/)
				{
					$r1 = "NONE";
				}

				$outtext .= "$filename\t$r1\t$r2\n";
			}

			my @out = format_output($author, $outtext, $log, $module, $tagname, $ccrecipients);
			$fmtText .= $out[0];
			$fmtHtml .= $out[1];

		}

		if ($opt_byauthor)
		{
			# Send mail
			send_mail($fmtText, $fmtHtml, $module, $recipient, $ccrecipients, $author);
			$fmtText = $fmtHtml = "";
		}
	}

	if (!$opt_byauthor)
	{
		# Send mail
		send_mail($fmtText, $fmtHtml, $module, $recipient, $ccrecipients, undef);
	}
}

sub dolog($$$)
{
	my ($module, $commitlog, $recipient) = @_;

	if ($opt_verbose)
	{
		print STDERR "Processing changelog";
		print STDERR " from '$commitlog'" if $commitlog;
		print STDERR " on repository '$module'" if $module;
		print STDERR "...\n";
	}

	if ($opt_rlog)
	{
		dolog_rlog($module, $commitlog, $recipient);
	}
	else
	{
		dolog_commitlog($module, $commitlog, $recipient);
	}
}

#
# MAIN ENTRY POINT
#

# Make sure that CVS doesn't use "/root" as $HOME
delete $ENV{"HOME"};

# Use SSH by default with the :ext: protocol
$ENV{"CVS_RSH"} = "ssh";

GetOptions(
	'outfile=s'	=> \$opt_outfile,
	'keeplogs'	=> \$opt_keeplogs,
	'sender=s'	=> \$opt_sender,
	'recipient=s'	=> \$opt_recipient,
	'maildomain=s'	=> \$opt_maildomain,

	'module=s'	=> \$opt_module,
	'prjtab=s'	=> \$opt_prjtab,
	'rlog'		=> \$opt_rlog,
	'stampdir=s'	=> \$opt_stampdir,
	'by-author'	=> \$opt_byauthor,

	'cvsroot=s'	=> \$opt_cvsroot,
	'cvsprefix=s'	=> \$opt_cvsprefix,
	'cvsurl=s'	=> \$opt_cvsurl,
	'bugurl=s'	=> \$opt_bugurl,
	'diff'		=> \$opt_diff,
	'difflimit=n'	=> \$opt_difflimit,

	'verbose'	=> \$opt_verbose,
	'help'		=> sub { pod2usage(1); },
	'man'		=> sub { pod2usage(-exitstatus => 0, -verbose => 2); },
) or pod2usage(2);

if (($opt_prjtab || $opt_rlog) && @ARGV)
{
	print STDERR "ERROR: input file arguments are mutually exclusive with --rlog and --prjtab modes.\n";
	pod2usage(1);
}

if($opt_prjtab)
{
	print STDERR "Opening prjtab file: $opt_prjtab...\n" if $opt_verbose;
	open PRJTAB, $opt_prjtab or die "couldn't open $opt_prjtab: $!\n";

	while (<PRJTAB>)
	{
		# Skip comments and blank lines
		next if /^#/ or /^\s*$/;

		# NOTE: email hogs all remaining fields (\n must be chomped)
		my ($prjname, $cvsdir, $email) = split(' ', $_, 3);
		chomp $email;

		my $commitlog;
		$commitlog = "$cvsdir/commitlog.new" if !$opt_rlog;

		# Strip away CVS directory when using rlog
		$opt_cvsprefix=$cvsdir if ($opt_rlog);

		dolog($prjname, $commitlog, $email);
	}

	close PRJTAB;
}
elsif ($opt_rlog)
{
	if (!$opt_cvsroot)
	{
		print STDERR "ERROR: --rlog specified and no --cvsroot given.\n";
		pod2usage(1);
	}

	# Fetch from CVS
	dolog($opt_module, undef, $opt_recipient);
}
else
{
	if (!@ARGV)
	{
		print STDERR "ERROR: no log files provided as input.\n";
		pod2usage(1);
	}

	# Process command line arguments
	while(my $logfile = shift @ARGV)
	{
		dolog($opt_module, $logfile, $opt_recipient);
	}
}

__END__

=head1 NAME

deluxeloginfo - Process CVS commit logs to generate e-mail report with hyperlinks to ViewCVS and Bugzilla

=head1 SYNOPSIS

deluxeloginfo [options] [<file> ...]

 Options:
   --outfile=file      use <file> as output instead of sending mail
   --sender=addr       specify sender address for CVS logs
   --maildomain=dom    specify e-mail domain for committers (used for To:)
   --recipient=addr    specify e-mail recipient or newsgroups (news:foo.bar.baz)
   --newsgroups=groups post log to a specified newsgroups (comma separated).
   --by-author         send one mail for each committer (currently only for rlog mode)

   --module            CVS module to work on
   --prjtab=file       use <file> as a prjtab file to find CVS repositories
   --rlog              use cvs rlog output instead of loginfo files
   --stampdir          directory to store timestamps for cvs rlog dates
   --keeplogs          keep log files instead of rotating them

   --cvsroot=root      base CVSROOT for use with cvs -d option
   --cvsprefix=dir     Repository prefix to strip away in logs
   --cvsurl=url        set URL for ViewCVS viewcvs.cgi (default: none)
   --bugurl=url        set URL for Bugzilla's show_bug.cgi (default: none)
   --diff              show diff for commits (requires --cvsroot)
   --difflimit=n       show up to <n> lines of diff output

   --verbose           turn on verbose diagnostic output
   --help              brief help message
   --man               full documentation

=head1 USAGE

Add this line to your CVSROOT/loginfo

   ALL (echo %{sVv}; echo "Author: $USER"; cat ; echo "---END---") >> $CVSROOT/commitlog.new

Put something like this in your crontab:

   29 */6 * * * root /usr/local/bin/deluxeloginfo \
       --prjtab=/etc/projects/prjtab \
       --cvsurl="http://cvs.develer.com/viewcvs.cgi" \
       --bugurl="http://bugs.develer.com/show_bug.cgi"

If you have multiple CVS repositories, you can process all them at once
by setting up a project description file like this:
 
   #NAME	CVSROOT					RECIPIENTS
   kde		/cvs/kde				kde-devel@lists.kde.org
   gnome	/cvs/gnome				gnome-devel@lists.gnome.org
   uclinux	:ext:bernie@cvs.uclinux.org:/cvsroot	uclinux-dev@uclinux.org
   gcc		:pserver:bernie@gcc.gnu.org:/cvs/gcc	news:comp.lang.c++,gnu.misc.discuss

Multiple recipients can be specified separated by commas.
Prefix the address with "news:" to post to newsgroups.

=head1 AUTHOR

Written by Bernardo Innocenti <bernie@develer.com>. Contact me for
patch submissions and bug reports.

=cut

