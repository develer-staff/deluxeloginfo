#!/usr/bin/perl -w
#
# $Id$
# Copyright 2002, 2003, 2004, 2005, 2006 Bernie Innocenti <bernie@codewiz.org>
#
# Dedicated to the memory of Gerry, an extraordinary engineer and
# a good friend.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Loosely based on KDE's loginfo.pl:
#   free of any copyright. Originally written by taj@kde.org with small changes
#   by coolo@kde.org and daniel.naber@t-online.de
#   Many improvements and fixes by dirk@kde.org
#
#
# TODO: Coalesce diffs of same file in same changeset with same comment
# TODO: Use a table for changeset summaries.
# TODO: Show nr. of files and nr. of lines changed in summary.
# TODO: Add review checklist below summary.
#
#

use strict;
use Getopt::Long;
use Pod::Usage;

my $versiontag = '$Revision$';
$versiontag =~ s/.*: (.*) .*/$1/;

my @text_mime_types =
   ( qr{^text/}, qr{^image/x-xbitmap$}, qr{^image/x-xpixmap$} );

# Command line options
my $opt_keeplogs;
my $opt_verbose;
my $opt_logfile = '';
my $opt_sender = "cvs\@develer.com";
my $opt_recipient = '';
my $opt_outfile = '';
my $opt_mail_command = '';
my $opt_prjtab = '';
my $opt_rlog = 1;
my $opt_stampdir = '/var/state/loginfo';
my $opt_byauthor;
my $opt_maildomain = '';
my $opt_weburl = '';
my $opt_bugurl = '';
my $opt_diff;
my $opt_html = 1;
my $opt_text = 1;
my $opt_encoding = 'UTF-8';
my $opt_difflimit = 0;
my $opt_startdate;
my $opt_enddate;
my $opt_startrevision;
my $opt_endrevision;
my $opt_root = '';
my $opt_prefix = '';
my $opt_module = '';
my $opt_index = 999;
my $opt_indexlines = 1;
my $opt_svn_config_dir;
my @opt_branches;

# Globals
my ($is_svn, $is_git, $is_hg);
my @svn_global_options;

#
# Print a message (arg 1) followed by an optional multi-line preformatted block (arg 2)
#
sub log_output
{
	if ($opt_verbose)
	{
		my ($msg, $text) = @_;
		print STDERR "  $msg" . ($text ? ":" : "") . "\n";
		if ($text)
		{
			foreach (split '\n', $text) { print "    $_\n"; }
		}
	}
}

# FIXME - remove this and add filerev subclasses
sub _head_branch { return $is_svn ? "trunk" : "HEAD"; }

#
# Hold a file-revision pair
#
package FileRev;

	#
	# Construct a FileRev object
	#
	# SYNOPSIS: FileRev->new(repodir, filename, r1, r2, tag, date, keywords,
	#                        is_directory)
	#
	sub new($$$$$$$$)
	{
		#
		# Collect arguments and create instance
		#
		my $class = shift;
		my $repodir = shift;
		my $filename = shift;
		my $self = {
			r1 => shift,
			r2 => shift,
			tag => shift,
			date => shift,
			keywords => shift,
			is_directory => shift,
		};
		bless $self, $class;

		#
		# Normalize filename
		#

		# Prune ,v suffix from filename
		$filename =~ s|,v$||;

		# Prune CVS repository path from filename
		$filename =~ s|^$repodir/|| if $repodir;

		# Prune Attic directory from filename
		$filename =~ s|/Attic/|/|;

		# Prune leading '/' at the beginning of the path
		$filename =~ s|^/||;

		# Remove any spurious '//' sequences from CVS
		$filename =~ s|//|/|g;

		$self->{filename} = $filename;

		return $self;
	}

	# Return normalized filename
	sub filename { return shift->{filename}; }

	# Return old file revision
	sub r1 { return shift->{r1} || "NONE"; }

	# Return new file revision
	sub r2 { return shift->{r2} || "NONE"; }

	# Return the branch tag for the file
	sub tag { return shift->{tag} || main::_head_branch(); }

	# Return commit timestamp
	sub date { return shift->{date}; }

	# Tell if this file is binary/a directory
	sub is_binary { return shift->{keywords} eq "kb"; }
	sub is_directory { return shift->{is_directory} }

#
# Handle a list of changed files, the associated log message and the author
#
package ChangeSet;

	# Construct a new ChangeSet.  Arg1 is the author, arg2 is the log message
	sub new($$$)
	{
		my ($class, $author, $log) = @_;
		bless {
			author => $author,
			log => $log,
			files => [],
			tags => {},
			date => "1970/01/01 00:00:00"
		}, $class;
	}

	# Add a new FileRev entry
	sub add
	{
		my ($self, $filerev) = @_;

		push @{$self->{files}}, $filerev;

		# Collect date of newest change
		$self->{date} = $filerev->{date} if ($self->{date} lt $filerev->{date} );

		# Collect tag set
		$self->{tags}{$filerev->tag} = 1;
	}

	# Retrieve the author name
	sub author { return shift->{author}; }

	# Retrieve the log message
	sub log { return shift->{log}; }

	# Return the branch tag for the file
	sub tags
	{
		my $self = shift;

		return %{$self->{tags}} ? keys %{$self->{tags}} : ();
	}

	sub is_head
	{
	    my $self = shift;
	    my @tags = $self->tags;

	    return @tags == 1 && $tags[0] eq main::_head_branch();
	}

	# Return an array of FileRev objects
	sub files
	{
		my @fr = @{shift->{files}};

		# Return base filename and extension
		sub split_extension($)
		{
			my $name = shift;
			$name =~ /^(.*)\.([^.\/]*)$/;
			return ($1 || $name, $2 || "");
		}
		sub is_header($) { shift =~ /^h|hh|hxx|hpp|h\+\+$/ }
		sub is_source($) { shift =~ /^c|cpp|cc|cxx|C|c\+\+$/ }

		# Fancy sort that makes headers appear before sources, to make code
		# reviews somewhat easier.
		sort {
			my $name_a = $a->filename();
			my $name_b = $b->filename();

			# Split into basename + extension
			my ($base_a, $ext_a) = split_extension($name_a);
			my ($base_b, $ext_b) = split_extension($name_b);

			#DEBUG
			#print "base_a=$base_a, ext_a=$ext_a, base_b=$base_b, ext_b=$ext_b\n";

			# Same basename and non-null extensions?
			if ($base_a eq $base_b)
			{
				# Sort headers before implementations
				return -1 if is_header($ext_a) && is_source($ext_b);
				return +1 if is_header($ext_b) && is_source($ext_a);
			}

			# Sort normally
			return $name_a cmp $name_b;
		} @fr;
	}


#
# Maintain a collection of ChangeSets sorted by authors and log messages.
#
package CSList;

	sub new($$$)
	{
		my $class = shift;
		bless { authors => {} }, $class;
	}

	#
	# Add a new FileRev entry to an existing ChangeSet.
	# If no ChangeSet exists for the given log, create a new one.
	#
	sub add_filerev
	{
		my ($self, $author, $log, $filerev) = @_;

		my ($changeset, $l);

		# Complain for missing log entries
		$log = "*** Empty log message! ***" if !$log;

		# Do we know this author yet?
		if (!($l = $self->{authors}{$author}))
		{
			main::log_output("Create new author $author");
			$l = $self->{authors}{$author} = {};
		}

		# Do we know this log yet?
		if (!($changeset = ${$l}{$log}))
		{
			main::log_output("Create new ChangeSet for $author", $log);
			$changeset = ChangeSet->new($author, $log);
			${$l}{$log} = $changeset;
		}

		main::log_output("Append new file for $author on " . $filerev->filename
			. " rev " . $filerev->r1 . " -> " . $filerev->r2);
		$changeset->add($filerev);
	}

	#
	# Construct a FileRev entry and add it with CSList::add_filerev()
	#
	# SYNOPSIS: cs_list->add_file(author, log, repodir, file, r1, r2, tagname, date, keywords)
	#
	sub add_file
	{
		my $self = shift;
		my $author = shift;
		my $log = shift;
		my $filerev = FileRev->new(@_);
		$self->add_filerev($author, $log, $filerev);
	}

	#
	# Return a list containing all author names.
	#
	sub authors
	{
		return keys %{shift->{authors}};
	}

	#
	# Return a list containing all ChangeSet objects for a specified author
	# the list is sorted in ascending date order.
	#
	sub changesets
	{
		my ($self, $author) = @_;

		return sort { $a->{date} cmp $b->{date} } values %{$self->{authors}{$author}};
	}

	#
	# Store revision range in which all diffs stands.
	#
	sub set_revision_range
	{
		my ($self, $range) = @_;
		$self->{range} = $range;
	}


#
# Main program
#
package main;


sub add_to_cc(\$$)
{
	my ($cc, $email) = @_;
	$$cc .= length($$cc) ? ", $email" : "$email" if($$cc !~ /$email/);
}

# include first file in second file
sub append_file($$)
{
	local $/; # enable localized slurp mode
	open(my $in,  '<', shift) or die $!;
	open(my $out, '>>', shift) or die $!;
	print {$out} <$in>;
}

# Create empty file with specified owner
sub create_empty_file($;$$)
{
	my $filename = shift;

	open(FILE, ">$filename") or die "$filename: $!";
	close FILE;

	if (my $user = shift)
	{
		my (undef,undef,$uid,$gid) = getpwnam($user) or die $!;
		chown $uid, $gid, $filename;

		if (my $mode = shift)
		{
			chmod $mode, $filename;
		}
	}
}

#
# Generate unique filename from the repository root and module.
#
sub stamp_filename($)
{
	my $module = shift;

	my $stamp = $opt_root;
	$stamp .= "/$module" if $module;
	$stamp =~ tr|:\/\\@.|_____|;
	$stamp .= ".stamp";
	$stamp = "$opt_stampdir/$stamp";

	return $stamp;
}

sub svn_date($)
{
	use Date::Format;
	use File::stat;

	my $mtime;
	if (my $st = stat(shift))
	{
		$mtime = $st->mtime;
	}
	else
	{
		$mtime = time - 60*60*24;
	}
	return time2str('{%Y-%m-%d %H:%M:%S %z}', $mtime, "UTC")
}


#
# Return an SVN date or revision range in the format "{OLD}:{NEW}" or
# "R1:R2" from the given stamp file.
#
sub svn_date_range($$)
{
	my ($module, $stamp) = @_;
	my $dates;

	if ($opt_startdate)
	{
		$dates = "{$opt_startdate}";
	}
	else
	{

		# Get timestamp from file, touch it and get filestamp again
		# (diff since yesterday if no previous stamp file is present).
		$dates = svn_date($stamp);
	}

	$dates .= ":";

	if ($opt_enddate)
	{
		$dates .= "{$opt_enddate}";
	}
	elsif (!$opt_endrevision)
	{
		# Create a new file with the current datestamp
		# (we'll overwrite the old stamp later, only on success)
		if (! -d $opt_stampdir)
		{
			print STDERR "Creating $opt_stampdir since it doesn't exist\n";
			mkdir $opt_stampdir || die "Can't create $opt_stampdir: $!\n";
		}
		create_empty_file("$stamp.new");
		svn_save_revision("$stamp.new", svn_last_changed($module)); #svn_last_rev($module));
		$dates .= svn_date("$stamp.new");
	}

	return $dates;
}

#
# url, field -> value
# Get specified field's value from svn info output:
#
# Path: .
# [...]
# Last Changed Author: sally
# Last Changed Rev: 11754
# Last Changed Date: 2007-01-16 12:34:13 +0100 (Tue, 16 Jan 2007)
# [...]
#
# TODO: use xml.
#
sub svn_info($$)
{
	my ($url,$field) = @_;
	open my $svninfo, "svn @svn_global_options info --non-interactive $url 2>/dev/null |" or die;
	while (<$svninfo>)
	{
		if (/^$field: (\S+)/)
		{
			close $svninfo;
			return $1;
		}
	}
	close $svninfo;
}

#
# module -> last changed revision
#
sub svn_last_changed($)
{
	return svn_info("$opt_root/" . shift, "Last Changed Rev");
}

#
# module -> head
#
sub svn_head($)
{
	return svn_info("$opt_root/" . shift, "Revision");
}


#
# timestamp_filename -> revision
#
# If timestamp file does not exist or it's empty, return -1.
#
sub svn_rev($)
{
	my $rev = "";
	if (open my $revision, shift)
	{
		chomp($rev = <$revision> || "");
		close $revision;
		return ($rev =~ /\d+/) ? $rev : -1;
	}
	return -1;
}

#
# Write last committed revision in timestamp file.
#
sub svn_save_revision($$)
{
	my ($filename, $last_rev) = @_;
	open my $revision, ">$filename" or die;
	print $revision "$last_rev";
	close $revision;
}

#
# module, timestamp_filename -> revision range
#
# Build argument for svn's -r option.
# If last revision is HEAD return 0.
#
sub svn_rev_range($$)
{
	my ($module, $filename) = @_;
	my $last_diff = $opt_startrevision || svn_rev($filename);
	my $head = $opt_endrevision || svn_last_changed($module);

	if ($last_diff == $head)
	{
		return 0;
	}
	my @rev = ($last_diff + 1, $head);

	# get date range and update revision in file
	# TODO: should be splitted in two functions
	# FIXME: only used to update revision in file: rename
	my $date_range = svn_date_range($module, $filename);

	if ($rev[0] < 0)
	{
		print STDERR "Wrong starting revision: $rev[0] \n" if $opt_verbose;
		return;
	}

	if (!$rev[1])
	{
		return $rev[0];
	}

	if ($rev[0] > $rev[1])
	{
		print STDERR "Wrong revision range " . join (":", @rev) . "\n" if $opt_verbose;
		exit (1);
	}

	return join(":", @rev);
}

#
# timestamp_filename -> revision range
#
# Build git revision range.
#
sub git_rev_range($\@)
{
	my $filename = shift;
	my $branches = shift;

	if ($opt_endrevision && !$opt_startrevision)
	{
		die "for Git, specify both start and end revision or none";
	}

	if ($opt_startrevision)
	{
		return { _ => [ $opt_endrevision, "^$opt_startrevision" ] };
	}
	else
	{
		my %revisions;
		if (open my $revision, $filename)
		{
			while (defined (my $line = <$revision>))
			{
				next if $line =~ /^\s*$/;
				$line =~ /^(\S+)\s(\S+)$/
				  or die "Invalid stamp line: '$line'";
				$revisions{$2} = [ $2, "^$1" ];
			}

			# add ranges for newly-created branches; this
			# will list revisions once even in case of
			# multiple branches created between two dli
			# runs; revisions might be attributed to the
			# "wrong" branch but there is no way around it
			my @old_branches = grep $revisions{$_}, @$branches;
			my @new_branches = grep !$revisions{$_}, @$branches;
			foreach my $branch (@new_branches)
			{
				$revisions{$branch} =
				  [ $branch, map "^$_", @old_branches ];
				push @old_branches, $branch;
			}
		}
		else
		{
			print STDERR "Warning: can't find last rev file: $filename\n" if $opt_verbose;
			foreach my $branch (@$branches)
			{
				$revisions{$branch} =
				  [ $branch, "^$branch^@" ];
			}
		}

		return \%revisions;
	}
}

#
# timestamp_filename -> revision range
#
# Build hg revision range.
#
sub hg_rev_range($\@)
{
	my $filename = shift;
	my $branches = shift;

	if ($opt_endrevision && !$opt_startrevision)
	{
		die "for hg, specify both start and end revision or none";
	}

	if ($opt_startrevision)
	{
		return { _ => [ $opt_endrevision, $opt_startrevision ] };
	}
	else
	{
		my %revisions;
		if (open my $revision, $filename)
		{
			while (defined (my $line = <$revision>))
			{
				next if $line =~ /^\s*$/;
				$line =~ /^(\S+)\s(\S+)$/
				  or die "Invalid stamp line: '$line'";
				$revisions{$2} = [ $2, $1 ];
			}

			# add ranges for newly-created branches; this
			# will list revisions once even in case of
			# multiple branches created between two dli
			# runs; revisions might be attributed to the
			# "wrong" branch but there is no way around it
			my @old_branches = grep $revisions{$_}, @$branches;
			my @new_branches = grep !$revisions{$_}, @$branches;
			foreach my $branch (@new_branches)
			{
				$revisions{$branch} =
				  [ $branch, map "$_", @old_branches ];
				push @old_branches, $branch;
			}
		}
		else
		{
			print STDERR "Warning: can't find last rev file: $filename\n" if $opt_verbose;
			foreach my $branch (@$branches)
			{
				$revisions{$branch} =
				  [ $branch, "tip" ];
			}
		}

		return \%revisions;
	}
}

sub bugzillate($)
{
	return unless $opt_bugurl;

	# Match "Bug 123", "bug #123", or just "#123"
	# Replace with $opt_bugurl, with @BUG@ interpolated to the bug number
	$_[0] =~ s{((?:[Bb]ug\s*(?:#|)|#)\s*)(\d{1,6})}{
		my ($pfx, $id) = ($1, $2);
		my $url = $opt_bugurl;
		$url =~ s/\@BUG\@/$id/g;
		"<a href='$url'>$pfx$id</a>"
	}ge;
}

#
# Print a multi-part MIME header
#
sub mime_header(*$)
{
	my ($fh, $type) = @_;
	print $fh <<EOF;
MIME-Version: 1.0
Content-Type: $type;
  boundary="Boundary-00=_R+zZ+ucfVzM1q7w"

This is a multi-part message in MIME format.

EOF
}

#
# Print MIME part header
#
sub mime_part(*$)
{
	my ($fh,$type) = @_;

	print $fh <<EOF;
--Boundary-00=_R+zZ+ucfVzM1q7w
Content-Type: $type;
  charset="$opt_encoding"
Content-Disposition: inline

EOF
}

#
# Print MIME footer
#
sub mime_footer(*)
{
	my $fh = shift;
	print $fh <<EOF;
--Boundary-00=_R+zZ+ucfVzM1q7w--
EOF
}

#
# Print ASCII e-mail signature
#
sub signature(*$)
{
	my $fh = shift;
	my $toascii = shift;

	my $sig = <<EOF;

<p>--<br />
<small>Generated by <a href="http://www.codewiz.org/projects/index.html#loginfo">Deluxe Loginfo</a> $versiontag by Bernie Innocenti &lt;bernie\@develer.com&gt;</small></p>
EOF

	unhtml($sig) if $toascii;
	print $fh $sig;
}

#
# Print HTML header
#
sub html_header(*$)
{
	my $fh = shift;
	my $title = shift;

	print $fh <<EOF;
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=$opt_encoding">
<title>$title</title>
</head>
<body text='#000000' bgcolor='#ffffff'>
EOF
}

#
# Print HTML footer
#
sub html_footer(*)
{
	my $fh = shift;

	print $fh <<EOF;
</body>
</html>
EOF
}

sub send_mail(\$\$\$$$$$)
{
	my ($text, $html, $summary, $module, $to, $cc, $author) = @_;

	# Avoid sending empty mails
	if (!$$text)
	{
		print STDERR "Not sending empty mail.\n" if $opt_verbose;
		return;
	}

	# Count the change sets in the summary
	my @foo = split /^/, $$summary;
	if (!defined($opt_index) || (($opt_index > 0) && @foo <= $opt_index))
	{
		$summary = "";
	}
	else
	{
		# Complete the summary
		$summary = "<h3>ChangeSet Index:</h3>\n<ul>\n" . $$summary . "</ul>\n";
		bugzillate $summary;
	}

	# Build subject line
	my $subject = $author ? "changes by $author" : "change log";
	$subject .= " for $module" if ($module);
	{
		# Compute current time
		my (undef , undef, undef, $mday, $mon, $year, undef, undef, undef) = localtime;
		$year += 1900;
		$mon += 1;
		$subject .= sprintf(" (%04d-%02d-%02d)", $year, $mon, $mday);
	}

	my $from;
	if ($author =~ /\@\w/) # should match all e-mail addresses
	{
		$from = $author;
	}
	elsif ($author and $opt_maildomain)
	{
		$from = "$author <$author\@$opt_maildomain>";
	}
	else
	{
		$from = "$opt_sender <$opt_sender>";
	}

	my $newsgroups = "";
	my $mail_command = $opt_mail_command;

	# Force recipient if set
	if ($opt_recipient)
	{
		$to = $opt_recipient;
	}

	# Strip "mailto:" (the default)
	if ($to =~ /^mailto:(.+)/)
	{
		$to = $1;
	}
	# Match newsgroups
	elsif ($to =~ /^news:(.+)/)
	{
		$newsgroups = $1;
		$to = "";
		$mail_command ||= '/usr/bin/inews -h';
	}
	# default to sendmail
	$mail_command ||= '/usr/bin/sendmail -t';

	if ($opt_outfile)
	{
		print STDERR "Writing mail to '$opt_outfile'...\n" if $opt_verbose;
		open (MAIL, ">>$opt_outfile") or die "Couldn't open outfile: $!";
	}
	elsif ($newsgroups || $to)
	{
		print STDERR "Sending with '$mail_command'...\n" if $opt_verbose;
		open (MAIL, "|$mail_command") or die "Couldn't exec '$mail_command': $!";
	}
	else
	{
		print STDERR "No recipient, discarding mail.\n" if $opt_verbose;
		open (MAIL, ">/dev/null") or die "Couldn't open /dev/null: $!";
	}

	print MAIL "From: $from\n";
	print MAIL "To: $to\n" if ($to);
	print MAIL "Cc: $cc\n" if ($cc);
	print MAIL "Newsgroups: $newsgroups\n" if ($newsgroups);
	print MAIL "Subject: $subject\n";

	#
	# Out intent here is to generate:
	#  - a plain ASCII message when no HTML output is present
	#  - a MIME multi-part alternative message when we have both HTML and ASCII output
	#  - a MIME multi-part mixed message when we have HTML alone
	#
	my $mime_type = ($opt_html && $opt_text) ? "multipart/alternative" : "multipart/mixed";
	mime_header(*MAIL, $mime_type) if $opt_html;

	# End of mail headers
	print MAIL "\n";

	mime_part(*MAIL, 'text/plain') if ($opt_text && $opt_html);

	if ($opt_text)
	{
		print MAIL unhtml($summary);
		print MAIL $$text;
		signature(*MAIL, 1);
	}

	if ($opt_html)
	{
		mime_part(*MAIL, 'text/html');
		html_header(*MAIL, $subject);
		print MAIL $summary;
		print MAIL $$html;
		signature(*MAIL, 0);
		html_footer(*MAIL);
		mime_footer(*MAIL);
	}

	close(MAIL);

	# Clear buffers
	$$text = "";
	$$html = "";
}

sub dodiff($$$$)
{
	my ($module, $file, $r1, $r2) = @_;
	my $copts = "";
	my $is_diff = 1;

	# Regex to match source files (doesn't work with cvs rdiff)
	#my $srcfile = '\.(cpp|cc|cxx|C|c\+\+|c|l|y|h|hh|hxx|hpp|h\+\+|pl|jsp|java|py|sh)$';
	#$copts = "dpbB" if ($file =~ /$srcfile/);

	# Avoid diffs for removed files
	return "" if ($r2 eq "NONE");

	my @args;
	if ($is_svn)
	{

		if ($r1 eq "NONE")
		{
			@args = ('svn', @svn_global_options, 'cat', "-r$r2", "$opt_root/$file\@$r2");
			$is_diff = 0;
		}
		else
		{
			@args = ('svn', @svn_global_options, 'diff', "-r$r1:$r2", "$opt_root/$file\@$r2");
		}
	}
	elsif ($is_git)
	{
		if ($r1 eq "NONE")
		{
			@args = ('git', "--git-dir=$opt_root", 'show', $r2, '--', $file);
		}
		else
		{
			@args = ('git', "--git-dir=$opt_root", 'diff', "$r1..$r2", '--', $file);
		}
	}
	elsif ($is_hg)
	{
		if ($r2 eq "NONE")
		{
			@args = ('hg', 'diff', '--cwd', $opt_root, '-r', "$r1:$r2", "$file");
		}
		else
		{
			@args = ('hg', 'diff', '--cwd', $opt_root, '-c', $r2, "$file");
		}
	}

	print STDERR "+ " . join(' ', @args) . "\n" if $opt_verbose;
	open(DIFF, "-|") || exec @args;

	my $cnt = 0;
	my $hunk = "";
	my $interesting = 0;
	my $size_limit = 0;
	my $diff = "";

	if (!$is_diff)
	{
		$hunk .= ("=" x 67) . "\n";
		$hunk .= "--- /dev/null\n";
		$hunk .= "+++ $file\t(revision $r2)\n";
	}

	my $seen_git_index = $is_git ? 0 : 1;
	while(<DIFF>)
	{
		next if (/^Index:/);
		if (!$seen_git_index)
		{
		    next unless /^index /;
		    $seen_git_index = 1;
		    $_ = ('=' x 70) . "\n";
		}

		if ($is_hg)
		{
			if (/^diff/) {
				$_ = ('=' x 70) . "\n";
			}
		}

		$cnt++;

		# Truncate diff when it exceeds <difflimit>
		# or if the size grows over <difflimit> full lines of 80 characters.
		if ($opt_difflimit and
			(($cnt > $opt_difflimit) or (length($diff) + length($hunk) > $opt_difflimit * 80)))
		{
			# Limit exceeded: discard further input and exit
			while (<DIFF>) {}
			$size_limit = 1;
			last;
		}

		if ($is_diff)
		{
			# Begin of a new hunk?
			if (/^@@/)
			{
				# Consider the hunk only if it wasn't boring
				$diff .= $hunk if $interesting;
				$hunk = "";
				$interesting = 0;
			}

			# A change that doesn't only contain keywords output is interesting.
			$interesting++ if /^[\-\+]/
				&& !/\#\*\#/ && !/\*\#\*/ && !/\$(Version|Revision|Id|Log):/;

			# Subversion doesn't print the full pathname with remote diffs
			s{(\+\+\+|---) [^/]+\t(.*revision.*)}{$1 $file\t$2};
		}
		else
		{
			# Make it look like a diff
			$hunk .= "+";
		}

		$hunk .= $_;
	}
	close(DIFF);

	# Notify diff errors
	$? and $diff .= "*** DIFF FAILED: $! ***";

	# Pick last hunk too
	$diff .= $hunk if ($interesting || !$is_diff);
	$size_limit and $diff .= "*** SIZE LIMIT EXCEEDED - DIFF TRUNCATED ***";
	$diff .= "\n" if length($diff);

	return $diff;
}

#
# Escape characters with special meaning for HTML in the passed string(s).
#
sub htmlize
{
	foreach (@_)
	{
		s/&/&amp;/g;
		s/</&lt;/g;
		s/>/&gt;/g;
	}
}

#
# Remove HTML tags from the passed string(s), trying to retain some formatting.
#
# Note: When called in void context, arguments are modified in-place,
#       otherwise unhtml() returns the translated strings.
#
sub unhtml
{
	my @copy;

	# Copy arguments if caller expects a result
	foreach (defined(wantarray) ? @copy = @_ : @_)
	{
		# Replace hyperlinks with plain-text versions
		s#<a\s+.*href=['"](.*?)['"](.*?)>(.*?)</a>#$3 [$1]#g;

		# Break paragraphs
		s#<br\s*/?>#\n#g;
		s#</p>#\n#g;

		# Remove all tags
		s#<(.*?)>##g;

		# Translate some commonly used entities
		s#&amp;#&#g;
		s#&lt;#<#g;
		s#&gt;#>#g;
	}

	return defined(wantarray) ? @copy : undef;
}

sub diff2html($)
{
	my ($newstyle, $oldstyle) = ("", "");
	my $out = "<pre>\n";

	foreach (split /\n/, shift)
	{
		# Remove trailing \n
		chomp;

		# Replace HTML reserved chars with entities
		htmlize $_;

		# Mark leading CRs at EOL
		s/\r$/<span style="background-color: #FF0000">&lt;CR&gt;<\/span>/;

		# Mark leading whitespace at EOL
		s/([^ ])(\s+)$/$1<span style="background-color: #FF0000">$2<\/span>/;

		# Mark hidden whitespace before TABs
		s/([^ ])( +)\t/$1<span style="background-color: #FF0000">$2<\/span>\t/;

		# Replace long runs of '===' with a horizontal ruler
		s#^={30,}#<hr />#;

		SWITCH: {
			/^(--- |\+\+\+ |diff)/ && do { $newstyle = "006600"; last SWITCH };
			/^\+/                  && do { $newstyle = "000088"; last SWITCH };
			/^-/                   && do { $newstyle = "880000"; last SWITCH };
			/^@@/                  && do { $newstyle = "997700"; last SWITCH };
			/^\*\*\*/              && do { $newstyle = "FF0000"; last SWITCH };
			$newstyle = "";
		}

		# Optimization: avoid printing redundant <font>...</font> pairs
		if ($newstyle ne $oldstyle)
		{
			$out .= "</font>" if ($oldstyle);
			$out .= "<font color='#$newstyle'>" if ($newstyle);
			$oldstyle = $newstyle;
		}

		$out .= "$_\n";
	}
	$out .= "</font>" if ($oldstyle);
	$out .= "</pre>\n";
	return $out;

### BEGIN: EXPERIMENTAL/UNUSED CODE ###
	# Fork
	my $pid = open (ENSCRIPT_OUTPUT, "-|");
	die ("can't fork") unless defined($pid);
	if (!$pid)
	{
		# In child: pass text diff to enscript and die
		open (ENSCRIPT_INPUT, "|-") || exec 'enscript', '--color', '-Whtml', '-Ediffu', '-o', '-', '-';
		print ENSCRIPT_INPUT shift;
		exit 0;
	}
	else
	{
		# In parent: collect enscript output
		my $out = "";
		while(<ENSCRIPT_OUTPUT>)
		{
			$out .= $_ if (/^<PRE>/ .. /<\/PRE>/)
		}
		return $out;
	}
### END: EXPERIMENTAL/UNUSED CODE ###
}

sub format_output($$$\$)
{
	my ($csnum, $changeset, $module, $ccrecipients) = @_;
	my ($fmtText, $fmtHtml, $summary);
	my $diff = "";
	my @files = $changeset->files;
	my $author = $changeset->author;
	my $log = $changeset->log;
	my $tagname = join ', ', $changeset->tags;
	my $many_tags = $changeset->tags > 1;

	log_output("Processing ChangeSet by $author of "
			   . scalar @files
			   . " files.");

	# Do nothing for empty file lists
	if (@files == 0)
	{
		log_output("Skipping empty ChangeSet");
		return ();
	}

	if ($log =~ /((CVS|SVN).?SILENT)/)
	{
		# Ignore this commit and reset silent status
		log_output("Ignoring commit by $author because of '$1'", $log);
		return ();
	}

	my $incipit = "";
	my $incipit_lines = 0;
	foreach (split '\n', $log)
	{
		if (/^CCMAIL:\s*(.*)\s*$/)
		{
			add_to_cc($ccrecipients, $1);
			next;
		}

		# Collect first lines
		if ($incipit_lines < $opt_indexlines)
		{
			$incipit .= '<br />' if $incipit;
			htmlize $_;
			$incipit .= $_;
		}
		elsif ($incipit_lines == $opt_indexlines and $opt_indexlines != 0)
		{
			$incipit .= '[...]';
		}
		$incipit_lines++;
	}

	$summary .= "<li><a href='#cs$csnum'>CS$csnum</a> - $incipit</li>\n";

	$fmtHtml .= "<a name='cs$csnum'></a>\n";
	$fmtHtml .= "<table border='0' cellspacing='0' cellpadding='5' width='100%' bgcolor='#eeeeee'>\n";
	unless ($opt_byauthor and $changeset->is_head())
	{
		$fmtHtml .= "<tr><td colspan='3' bgcolor='#dddddd'>\n";
		unless ($opt_byauthor)
		{
			$fmtHtml .= " <font color='#bb2222'><strong>$author</strong></font>\n";
			$fmtText .= " *$author*";
		}
		unless ($changeset->is_head())
		{
			$fmtHtml .= " <font color='#225522'><em>(on branch $tagname)</em></font>\n";
			$fmtText .= " (on branch $tagname)";
		}
		$fmtHtml .= "</td></tr>\n";
		$fmtText .= ":\n";
	}

	$fmtText .= "$log\n";
	htmlize $log;
	bugzillate $log;
	$fmtHtml .= "<tr><td colspan='3' bgcolor='#dddddd'><pre>$log</pre></td></tr>\n";

	foreach my $filerev (@files)
	{
		my $file = $filerev->filename();
		my $r1 = $filerev->r1();
		my $r2 = $filerev->r2();

		# Guess CVS operation from revisions pair
		my $state = 'M';
		my $added_state = 'A';
		my $removed_state = $is_svn || $is_git ? 'D' : 'R';

		$state = $removed_state if ($r2 eq "NONE");
		$state = $added_state if ($r1 eq "NONE");

		# Find out a "good" revision to link to
		my $rev = ($r2 eq "NONE") ? $r1 : $r2;

		my $type_text = "";
		$type_text = "[BIN] " if ($filerev->is_binary);
		$type_text = "[DIR] " if ($filerev->is_directory);

		$fmtText .= sprintf("$state %6s  $type_text$file\n", $rev);

		my $statelink = $state;
		if ($opt_weburl)
		{
			# Prepend a slash to the module name if needed, define to an empty string otherwise
			# TODO move to the backend module when splitted
			my $module_path = $module && !$is_svn ? "/$module" : "";

			if ($state eq 'M')
			{
				$statelink = "<a href=\"$opt_weburl$module_path/$file.diff?r1=text&amp;tr1=$r1&amp;r2=text&amp;tr2=$r2&amp;diff_format=h\">$state</a>";
			}
			else # 'R' or 'A'
			{
				$statelink = "<a href=\"$opt_weburl$module_path/$file?rev=$rev&amp;content-type=text/vnd.viewcvs-markup\">$state</a>";
			}
		}

		my $color = "";
		my $color_end = "";
		if ($state eq 'A') { $color = '<font color="#000088">' };
		if ($state eq 'R') { $color = '<font color="#880000">' };
		$color_end = "</font>" if $color;

		$fmtHtml .= "<tr><td width='1%'>$statelink</td><td width='1%'>$color$rev$color_end</td><td width='100%'>$type_text$color$file$color_end</td></tr>\n";

		if ($opt_diff && !$filerev->is_binary && !$filerev->is_directory)
		{
			$diff .= dodiff($module, $file, $r1, $r2);
		}
	}
	$fmtHtml .= "</table>\n";

	# Put some spacing between the file list and the diff
	$fmtText .= "\n";

	if (length($diff))
	{
		$fmtText .= $diff . "\n";
		$fmtHtml .= diff2html($diff);
	}

	# Some spacing
	$fmtHtml .= "<p>&nbsp;</p>\n";

	return ($fmtText, $fmtHtml, $summary);
}

#
# Process accumulated logs
#
sub process_cslist($$$)
{
	my ($cslist, $module, $recipient) = @_;
	my $fmtText = "";
	my $fmtHtml = "";
	my $summary = "";
	my $ccrecipients = "";
	my $csnum = 1;

	foreach my $author ($cslist->authors)
	{
		foreach my $changeset ($cslist->changesets($author))
		{
			if (my @out = format_output($csnum,
										$changeset,
										$module,
										$ccrecipients))
			{
				$fmtText .= $out[0];
				$fmtHtml .= $out[1];
				$summary .= $out[2];
				$csnum++;
			}
		}

		if ($opt_byauthor)
		{
			send_mail($fmtText,
					  $fmtHtml,
					  $summary,
					  $module,
					  $recipient,
					  $ccrecipients,
					  $author);

			# Reset accumulated output
			$fmtText = $fmtHtml = $summary = "";
			$ccrecipients = "";
			$csnum = 1;
		}
	}

	if (!$opt_byauthor)
	{
		send_mail($fmtText,
				  $fmtHtml,
				  $summary,
				  $module,
				  $recipient,
				  $ccrecipients,
				  undef);
	}
}

#
# Read svn log in XML format.
# svn log command, repository path -> CSList
# Output tree (svn log -v --xml):
#
# log
#     logentry
#         revision
#         author
#         date
#         msg
#         paths
#             path
#                 action
#                 content
#                 [copyfrom-path]
#                 [copyfrom-rev]
#
sub svn_xml_log($$)
{
	use XML::Simple;
	use Data::Dumper;

	my ($cmd, $repodir) = @_;

	print STDERR "+ " . join(' ', @{$cmd}) . "\n" if $opt_verbose;

	open (my $fh, "-|") ||  exec @{$cmd};

	my $log = XMLin($fh,
					ForceArray => [ 'logentry', 'path' ],
					SuppressEmpty => 1);

	my $cslist = CSList->new;

	print '*'x79 ."\n" . Dumper($log) . '*'x79 ."\n" if $opt_verbose;

	unless(exists $log->{logentry})
	{
		return $cslist;
	}
	foreach my $logentry (@{$log->{logentry}})
	{
		# for commits generated by cvs2svn
		$logentry->{author} ||= '(no author)';
		foreach my $paths (values (%{$logentry->{paths}}))
		{
			foreach my $path (@{$paths})
			{
				my $rev = $path->{action} eq "D"
					? undef
					: $logentry->{revision};
				my $prev = $path->{action} eq "A"
					? exists $path->{'copyfrom-rev'}
						? $path->{'copyfrom-rev'}
						: undef
					: $logentry->{revision} - 1;
				my $msg = exists $logentry->{msg}
						? $logentry->{msg}
						: "";
				# diff seems already in bytes, so
				# force log message to bytes as well
				if (utf8::is_utf8($msg))
				{
					utf8::encode($msg);
				}

				# Fake 'keywords' to recognize binary files,
				# determine if the path is a directory
				# FIXME batch request for all paths
				my $keywords = '';
				my $is_directory;
				if ($rev)
				{
					my $url = $opt_root . $path->{content} .
						'@' . $logentry->{revision};

					print STDERR "Checking if $url is a directory\n" if $opt_verbose;
					my ($node_type) = svn_info($url, 'Node Kind');
					$is_directory = $node_type && $node_type eq 'directory';

					print STDERR "Checking mimetype for $url\n" if $opt_verbose;

					my $mime =
					    `svn @svn_global_options propget svn:mime-type '$url'`;
					chomp $mime;
					if (!defined $mime || !length($mime) ||
					    grep $mime =~ $_, @text_mime_types)
					{
						$keywords = '';
					}
					else
					{
						$keywords = 'kb';
					}
				}

				my $file_path = $path->{content};
				if ($opt_module)
				{
				    $file_path =~ s{$opt_module}{};
				}
				my $branch = '';
				if ($file_path =~ s{^/branches/([^/]+)(?=/)}{})
				{
				    $branch = $1;
				}
				elsif ($file_path =~ s{^/trunk(?=/)}{})
				{
				    # nothing to do
				}
				$cslist->add_file($logentry->{author},
								  $msg,
								  $repodir,
								  $path->{content},
								  $prev,
								  $rev,
								  $branch,
								  $logentry->{date},
								  $keywords,
								  $is_directory);
			}
		}
	}
	return $cslist;
}

#
# Process svn log output
#
sub svn_rlog($$)
{
	my ($module, $commitlog) = @_;
	my $stamp;
	my $skip_first_cs;

	#
	# Extract path prefix from the root
	#
	my $repodir;

	if ($opt_prefix)
	{
		$repodir = $opt_prefix;
	}
	else
	{
		$repodir = $module;
	}
#	elsif ($opt_root and $opt_root =~ m{^[\w\+]+://((?:[-\w\.]+/*)+)$})
#	{
#		$repodir = $1;
#	}

	$stamp = stamp_filename($module);
	my $range = svn_rev_range($module, $stamp);
	if (! $range)
	{
		return CSList->new;
	}
	my @args = $commitlog
		? ('cat', "$commitlog")
		: ('svn', @svn_global_options, 'log', '--non-interactive', '-v', '--xml', "-r$range", "$opt_root/$module");
	my $cslist = svn_xml_log(\@args, $repodir);
	rename "$stamp.new", "$stamp" if ($stamp);
	$cslist->set_revision_range($range);
	return $cslist;
}

#
# Process git log output
#
sub git_log_branch($$$$)
{
	my $module = shift;
	my $branch = shift;
	my $range = shift;
	my $cslist = shift;

	#
	# Extract path prefix from the root
	#
	my $gitdir = $opt_root;
	print STDERR "Reading log for branch $branch\n" if $opt_verbose && $branch;
	print STDERR "Reading log with gitdir='$gitdir'\n" if ($opt_verbose);

	my $new_tip = `git --git-dir=$gitdir rev-parse $range->[0]`;
	chomp $new_tip;
	my @args = ('git', "--git-dir=$gitdir", 'whatchanged', '--parents', '-m',
		    '--find-copies-harder', $new_tip, @{$range}[1 .. $#$range]);
	print STDERR "+ " . join(' ', @args) . "\n" if $opt_verbose;
	open(RLOG, "-|") || exec @args;

	# initialize vars with the default values
	my $r1 = "";
	my $r2 = "";
	my @log;
	my $date = "";
	my $author = "";
	my $keywords = "";
	my %seen; # whatchanged shows most merges multiple times

	while (<RLOG>)
	{
		if (/^commit ([0-9a-f]+)(?: ([0-9a-f]+)|$)/)
		{
			# mark previous commit as already seen
			$seen{$r2} = 1 if $r2;
			$r1 = $2;
			chomp $r1;
			$r2 = $1;
			# clean all variables when a new commit starts
			undef @log;
			$date = "";
			$author = "";
			$keywords = "";
		}
		elsif (/^Author: (.*)$/)
		{
			$author = $1;
		}
		elsif (/^Date: +(\w{3}) +(\w{3}) +(\d+) +(\S+) +(\d+) +(\S+)$/)
		{
			use Date::Format qw(time2str);
			use HTTP::Date qw(str2time);
			$date = time2str('%Y-%m-%dT%H:%M:%SZ',
					 str2time("$3 $2 $5 $4 $6"), 'UTC');
		}
		elsif (/^\s+(.*)$/)
		{
			push @log, $1 if length $1;
		}
		elsif (/^:.*\.\.\. (.)\d*\s+([^\t\n]+)(?:\t([^\t\n]+))?$/)
		{
			next if $seen{$r2};
			my $file = my $old_file = $2;
			my $operation = $1;
			if ($operation eq 'A')
			{
				$r1 = 'NONE';
			}
			elsif ($operation eq 'D')
			{
				$r2 = 'NONE';
			}
			elsif ($operation eq 'C')
			{
				$file = $3;
			}
			elsif ($operation eq 'R')
			{
				$file = $3;
			}
			my $log = join "\n", @log, '';
			# try to detect if file is binary
			if ($operation ne 'D') {
				my $diff = `git --git-dir=$gitdir diff $r2^! -- $file`;
				if ($diff =~ /\nindex .+\nBinary file.+$/)
				{
					$keywords = 'kb';
				}
			}
			if ($operation eq 'R')
			{
				$cslist->add_file($author, $log, $gitdir,
						  $old_file, $r1, 'NONE', $branch,
						  $date, $keywords);
			}
			$cslist->add_file($author, $log, $gitdir,
					  $file, $r1, $r2, $branch,
					  $date, $keywords);
		}
	}

	close RLOG;
	die "Reading git log failed: $!" if $?;

	return $new_tip;
}

#
# Process hg log output
#
sub hg_log_branch($$$$)
{
	my $module = shift;
	my $branch = shift;
	my $range = shift;
	my $cslist = shift;

	#
	# Extract path prefix from the root
	#
	my $hgdir = $opt_root;
	print STDERR "Reading log for branch $branch\n" if $opt_verbose && $branch;
	print STDERR "Reading log with hgdir='$hgdir'\n" if ($opt_verbose);

	my $new_tip = `hg identify -R $hgdir -r $range->[0] -i`;
	chomp $new_tip;

	# No changes
	if (@{$range}[1 .. $#$range] and $new_tip eq @{$range}[1 .. $#$range])
	{
		return $new_tip
	}

	my @args = ('hg', 'log', '--cwd', $hgdir, '-b', $branch, '--template', '__START__\nchangeset: {node}\nauthor: {author}\ndate: {date|rfc822date}\nfiles: {files}\nfile_adds: {file_adds}\nfile_dels: {file_dels}\n{desc}\n__END__\n', '-r', $new_tip.':'.@{$range}[1 .. $#$range]);
	print STDERR "+ " . join(' ', @args) . "\n" if $opt_verbose;
	open(RLOG, "-|") || exec @args;

	# initialize vars with the default values
	my $r1 = "";
	my $r2 = $new_tip;

	my $date = "";
	my $author = "";
	my @log;
	my %files;

	while (<RLOG>)
	{
		if (/^__START__$/)
		{
			$date = '';
			$author = '';
			undef @log;
			undef %files;
		}
		elsif (/^__END__$/)
		{
			my $log = join "\n", @log, '';
			foreach my $file (keys(%files)) {
				$cslist->add_file($author, $log, $hgdir, $file, $files{$file}[0], $files{$file}[1], $branch, $date, "");
			}
		}
		elsif (/^changeset: ([0-9a-f]+)$/)
		{
			$r1 = $r2;
			$r2 = $1;
		}
		elsif (/^author: (.+)$/)
		{
			$author = $1;
		}
		elsif (/^date: (.+)$/)
		{
			use Date::Format qw(time2str);
			use HTTP::Date qw(str2time);
			$date = time2str('%Y-%m-%dT%H:%M:%SZ', str2time($1));
		}
		elsif (/^files: (.+)$/)
		{
			my @files = split(/\s/, $1);
		
			foreach my $file (@files) {
				$files{$file} = [$r1, $r2];
			}
		}
		elsif (/^file_adds: (.*)$/)
		{
			my @adds = split(/\s/, $1);

			foreach my $file (@adds) {
				$files{$file}[0] = 'NONE';
			}
		}
		elsif (/^file_dels: (.*)$/)
		{
			my @dels = split(/\s/, $1);

			foreach my $file (@dels) {
				$files{$file}[1] = 'NONE';
			}
		}
		else {
			push @log, $_ if length $_;
		}
	}

	close RLOG;
	die "Reading hg log failed: $!" if $?;

	return $new_tip;
}

sub git_log($)
{
	my $module = shift;
	my $gitdir = $opt_root;

	# A nested data structure to hold all collected log data
	my $cslist = CSList->new;

	my %branch_names;
	my $branch_options = '';
	foreach my $branch (@opt_branches)
	{
		if ($branch eq 'local')
		{
		    # noop
		}
		elsif ($branch eq 'remote')
		{
		    $branch_options .= ' -r';
		}
		elsif ($branch eq 'all')
		{
		    $branch_options .= ' -a';
		}
		else
		{
		    $branch_names{$branch} = 1;
		}
	}
	if (defined $branch_options)
	{
	    foreach my $branch (`git --git-dir=$gitdir branch $branch_options`)
	    {
		chomp $branch;
		$branch_names{substr $branch, 2} = 1;
	    }
	}
	my @branches = keys %branch_names;
	my $stamp = stamp_filename(undef);
	my $range = git_rev_range($stamp, @branches);
	my %new_tip;

	# FIXME make git_rev_range return value uniform
	if ($opt_startrevision)
	{
		git_log_branch($module, undef, $range->{_}, $cslist);
	}
	else
	{
		foreach my $branch (@branches)
		{
			$new_tip{$branch} =
			  git_log_branch($module, $branch, $range->{$branch},
					 $cslist);
		}
	}

	if (!$opt_startrevision)
	{
		create_empty_file("$stamp.new");
		open my $lastrev, '>', "$stamp.new";
		print $lastrev "$new_tip{$_} $_\n" foreach sort keys %new_tip;
		close $lastrev;
		rename "$stamp.new", "$stamp";
	}

	return $cslist;
}

sub hg_log($)
{
	my $module = shift;
	my $hgdir = $opt_root;

	# A nested data structure to hold all collected log data
	my $cslist = CSList->new;

	my %branch_names;
	foreach my $branch (@opt_branches)
	{
		$branch_names{$branch} = 1;
	}
	if (!%branch_names)
	{
		foreach my $branch (`hg -R $hgdir branches`)
		{
			$branch =~ /^(\S+)/;
			$branch_names{$1} = 1;
		}
	}
	my @branches = keys %branch_names;
	my $stamp = stamp_filename(undef);
	my $range = hg_rev_range($stamp, @branches);
	my %new_tip;

	# FIXME make hg_rev_range return value uniform
	if ($opt_startrevision)
	{
		hg_log_branch($module, undef, $range->{_}, $cslist);
	}
	else
	{
		foreach my $branch (@branches)
		{
			$new_tip{$branch} =
			  hg_log_branch($module, $branch, $range->{$branch},
					 $cslist);
		}
	}

	if (!$opt_startrevision)
	{
		create_empty_file("$stamp.new");
		open my $lastrev, '>', "$stamp.new";
		print $lastrev "$new_tip{$_} $_\n" foreach sort keys %new_tip;
		close $lastrev;
		rename "$stamp.new", "$stamp";
	}

	return $cslist;
}

sub dolog($$$)
{
	my ($module, $commitlog, $recipient) = @_;
	my $cslist;

	if ($opt_verbose)
	{
		print STDERR "Processing changelog";
		print STDERR " from '$commitlog'" if $commitlog;
		print STDERR " on repository '$module'" if $module;
		print STDERR "...\n";
	}

	# Match "protocol://path"
	$is_svn = ($opt_root =~ m{^[\w\+]+://(\w+@|)(/|)(?:[-\w\.]+(?::\d+)?/*)+$});

	# Match "git" - FIXME: just a placeholder
	$is_git = ($opt_root =~ m{^git}) || ($opt_root =~ m{\.git$});

	# Match "hg" - FIXME: just a placeholder
	$is_hg = ($opt_root =~ m{^hg}) || ($opt_root =~ m{\.hg$});

	# None? Try to guess from local repository
	if (!($is_svn or $is_git or $is_hg))
	{
		# Maybe it's a local path, try to determine whether it's SVN
		$is_svn = (-f "$opt_root/format");
		#TODO: add git

		print STDERR "Root appears to be a SVN local repository.\n" if $opt_verbose and $is_svn;
	}

	# Multiple matches? Something weird must have happened...
	$is_svn ||= 0; $is_git ||= 0; $is_hg ||= 0;
	if (($is_svn + $is_git + $is_hg) > 1) { die "Ambiguous root path '$opt_root'" };

	if ($is_svn)
	{
		my $root = svn_info($opt_root, 'Repository Root');
		# automa[tg]ically adjust $opt_root and $module
		if ($root ne $opt_root) {
			my $full = "$opt_root/$module";

			# should never happen
			if (   index($full, $root) != 0
			    || length($full) <= length($root))
			{
				die <<EOT;
You used --root='$opt_root' but the real repo root is '$root'.
EOT
			}

			$opt_root = $root;
			$module = $opt_module = substr $full, length($root) + 1;

			print STDERR "Auto-adjusting paths: -root=$opt_root --module=$module" if $opt_verbose;
		}

		$cslist = svn_rlog($module, $commitlog);
	}
	elsif ($is_git)
	{
		$cslist = git_log($module);
	}
	elsif($is_hg)
	{
		$cslist = hg_log($module);
	}
	else
	{
		die "Malformed root path: $opt_root";
	}

	process_cslist($cslist, $module, $recipient);
}

#
# MAIN ENTRY POINT
#

# Make sure that CVS doesn't use "/root" as $HOME
delete $ENV{'HOME'};

# Make sure SVN and CVS both run with utf8 encoding
$ENV{'LANG'} = 'en_US.UTF-8';

# Use SSH by default with the :ext: protocol
$ENV{'CVS_RSH'} = "ssh";

unless (GetOptions(
	'o|outfile=s'	=> \$opt_outfile,
	'sender=s'	=> \$opt_sender,
	'maildomain=s'	=> \$opt_maildomain,
	'to|recipient=s'=> \$opt_recipient,
	'mail-command=s'=> \$opt_mail_command,

	'by-author'	=> \$opt_byauthor,
	'diff'		=> \$opt_diff,
	'difflimit=n'	=> \$opt_difflimit,
	'index:n'	=> \$opt_index,
	'index-lines:n'	=> \$opt_indexlines,
	'html!'         => \$opt_html,
	'text|ascii!'   => \$opt_text,
	'encoding=s'	=> \$opt_encoding,

	'module=s'	=> \$opt_module,
	'prjtab=s'	=> \$opt_prjtab,
	'rlog!'		=> \$opt_rlog,
	'stampdir=s'	=> \$opt_stampdir,
	'startdate=s'   => \$opt_startdate,
	'enddate=s'     => \$opt_enddate,
	'startrevision=s'=>\$opt_startrevision,
	'endrevision=s' => \$opt_endrevision,
	'keeplogs'	=> \$opt_keeplogs,
	'root|cvsroot=s'=> \$opt_root,
	'prefix|cvsprefix=s' => \$opt_prefix,
	'branch=s'      => \@opt_branches,
	'svn-config-dir=s'=> \$opt_svn_config_dir,

	'weburl|cvsurl=s' => \$opt_weburl,
	'bugurl=s'	=> \$opt_bugurl,

	'v|verbose+'	=> \$opt_verbose,
	'h|help'	=> sub { pod2usage(1); },
	'man'		=> sub { pod2usage(-exitstatus => 0, -verbose => 2); },
))
{
	print STDERR "Try '$0 --help' for more information.\n";
	exit(1);
}

@svn_global_options = ("--config-dir=$opt_svn_config_dir")
    if $opt_svn_config_dir;

if (@ARGV)
{
	print STDERR "ERROR: extra arguments on command line (there is no commitlog support anymore)\n";
	pod2usage(1);
}

if ($opt_prjtab)
{
	print STDERR "Opening prjtab file: $opt_prjtab...\n" if $opt_verbose;
	open PRJTAB, $opt_prjtab or die "couldn't open $opt_prjtab: $!\n";

	while (<PRJTAB>)
	{
		chomp;

		# Skip comments and blank lines
		next if /^#/ or /^\s*$/;

		# NOTE: email hogs all remaining fields
		my ($prjname, $root, $email) = split(' ', $_, 3);

		if (!$prjname || !$root || !$email)
		{
			die "$opt_prjtab:$.: Illegal prjtab format.";
		}

		my $commitlog;
		if ($opt_rlog)
		{
			# Use directory as repository root, unless overridden by user
			$opt_root = $root;

			# Strip away repository path
			#$opt_prefix = "$root/$prjname";
		}
		else
		{
			$commitlog = "$root/commitlog.new" if !$opt_rlog;
		}

		dolog($prjname, $commitlog, $email);
	}

	close PRJTAB;
}
elsif ($opt_rlog)
{
	if (!$opt_root)
	{
		print STDERR "ERROR: --rlog specified and no --root given.\n";
		pod2usage(1);
	}

	# Fetch from SCM
	dolog($opt_module, undef, $opt_recipient);
}

__END__

=head1 NAME

deluxeloginfo - Generate commit logs for SVN or Git

=head1 SYNOPSIS

deluxeloginfo [OPTION]...

 Options to specify the repository:
   --root=ROOT         base repository path
   --prefix=DIR        repository prefix to strip away in logs
   --module=NAME       CVS module or subtree to work on
   --prjtab=FILE       use FILE as a prjtab file to find repositories
   --no-rlog           use loginfo files instead of remote repository access 
   --stampdir=DIR      where to store timestamps for cvs rlog and svn log
                       (default: /var/state/loginfo)
   --startdate=DATE    specify start date instead of picking it from stamp file
   --enddate=DATE      specify end date instead of picking it from stamp file
   --startrevision=NUM specify start revision instead of picking it from
                       stamp file (Subversion-only)
   --endrevision=NUM   specify end revision instead of picking it from
                       stamp file (Subversion-only)
   --keeplogs          keep log files instead of rotating them
   --branch=[local|remote|all|<branch-name>]
                       branches to track (Git and Hg only); can be specified
                       multiple times
   --svn-config-dir    alternative directory for SVN configuration
          
 Options for output redirection:
   -o, --outfile=FILE  use FILE as output instead of sending mail
   --sender=ADDR       sender e-mail address for log messages
   --maildomain=DOMAIN mail domain for committers (used for From:)
   --to=ADDR           comma-separated list of mail recipients or newsgroups
                       (devtools@lists.develer.com or news:comp.lang.c)
   --mail-command=CMD  command for sending mail; must accept the mail message
                       on standard input; defaults to 'sendmail -t'

 Options for output format:
   --by-author         send one mail for each committer
   --diff              show diff for commits (requires --root)
   --difflimit=N       show up to N lines of diff output
   --index[=N]         output a summary of ChangeSets.  If N is specified,
                       the index is printed only when it contains at least N
		       ChangeSets. Set to 0 to always print the index
   --index-lines=N     number of log lines in an index entry (default: 1)
   --notext            disable text output
   --nohtml            disable HTML output
   --encoding=ENC      set mail text encoding to ENC (default: UTF-8)

 Options for web links:
   --weburl=URL        set URL for web revision history viewer (default: none)
   --bugurl=URL        set URL for bug database (default: none)

 Miscellaneous options:
   -v, --verbose       turn on verbose diagnostic output
                       (specify twice to increase verbosity).
   -h, --help          brief help message
   --man               full documentation

=head1 USAGE

Put something like this in your crontab:

   29 */6 * * * root /usr/local/bin/deluxeloginfo \
       --prjtab=/etc/projects/prjtab \
       --weburl="http://cvs.develer.com/viewcvs.cgi" \
       --bugurl="http://bugs.develer.com/show_bug.cgi?id=@BUG@"

If you have multiple repositories, you can process all them at once
by setting up a project description file like this:

   #NAME	ROOT					RECIPIENTS
   kde		/repos/kde				kde-devel@lists.kde.org
   gnome	/cvs/gnome				gnome-devel@lists.gnome.org
   uclinux	:ext:bernie@cvs.uclinux.org:/cvsroot	uclinux-dev@uclinux.org
   gcc		svn+ssh://gcc.gnu.org/svn/gcc		news:comp.lang.c++,gnu.misc.discuss

Multiple recipients can be specified separated by commas.
Prefix the address list with "news:" to post to newsgroups.

=head1 VARIABLE SUBSTITUTION

The arguments to --bugurl and --weburl are subject to substitution
of the following variables:

   @BUG@        bug ID as matched in the log message

=head1 AUTHOR

Written by Bernie Innocenti <bernie@codewiz.org>.
Extended by Marco Benelli <marco@develer.com>.
Loosely based on KDE's loginfo.pl.

Contact any of us for patch submissions and bug reports.

=cut

