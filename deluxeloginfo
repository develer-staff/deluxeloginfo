#!/usr/bin/perl -w
#
# $Id$
# Copyright 2002, 2003, 2004 Bernardo Innocenti <bernie@develer.com>
#
# Dedicated to the memory of Gerry, an extraordinary engineer and
# a good friend.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Loosely based on KDE's loginfo.pl:
#   free of any copyright. Originally written by taj@kde.org with small changes
#   by coolo@kde.org and daniel.naber@t-online.de
#   Many improvements and fixes by dirk@kde.org
#
#
# $Log$
# Revision 2.34  2004/06/27 20:10:54  bernie
# Colorize added/removed files;  Nicer column widths for the file list.
#
# Revision 2.33  2004/06/27 19:36:28  bernie
# Grand Code Paths Unification.
#
# Revision 2.32  2004/06/27 18:32:39  bernie
# Sort ChangeSets in ascending date order.
#
# Revision 2.31  2004/06/27 17:45:07  bernie
# Fold all remaining rogue code into CSList class.
#
# Revision 2.30  2004/06/27 10:04:33  bernie
# Use ChangeLog class in place of bare data structure.
#
# Revision 2.29  2004/06/27 09:10:19  bernie
# Fold even more code into FileRev
#
# Revision 2.28  2004/06/27 08:40:32  bernie
# Prune CVS log.
#
# Revision 2.27  2004/06/27 08:28:36  bernie
# Prune CVS log.
#
# Revision 2.26  2004/06/27 08:27:55  bernie
# Mark enscript code as being unused.
#
# Revision 2.25  2004/06/27 08:25:16  bernie
# Ubiquitous usage of log_output().
#
# Revision 2.24  2004/06/27 08:17:29  bernie
# Introduce OO syntax for file revisions.
#

use strict;
use Getopt::Long;
use Pod::Usage;

my $versiontag = '$Revision$';
$versiontag =~ s/.*: (.*) .*/$1/;

# Command line options
my $opt_keeplogs;
my $opt_verbose;
my $opt_logfile = "";
my $opt_sender = "cvs\@develer.com";
my $opt_recipient = "";
my $opt_outfile = "";
my $opt_prjtab = "";
my $opt_rlog;
my $opt_stampdir = "/var/state/loginfo";
my $opt_byauthor;
my $opt_maildomain = "";
my $opt_cvsurl = "";
my $opt_bugurl = "";
my $opt_diff;
my $opt_difflimit = 0;
my $opt_cvsroot = "";
my $opt_cvsprefix = "";
my $opt_module = "";


#
# Print a message (arg 1) followed by an optional multi-line preformatted block (arg 2)
#
sub log_output
{
	if ($opt_verbose)
	{
		my ($msg, $text) = @_;
		print STDERR "  $msg" . ($text ? ":" : "") . "\n";
		if ($text)
		{
			foreach (split '\n', $text) { print "    $_\n"; }
		}
	}
}

#
# Hold a file-revision pair
#
package FileRev;

sub new($$$$$$)
{
	#
	# Collect arguments and create instance
	#
	my ($class, $cvsdir, $filename, $rev, $date, $removed) = @_;
	my $self = { date => $date };
	bless $self, $class;

	#
	# Normalize filename
	#

	# Prune ,v suffix from filename
	$filename =~ s|,v$||;

	# Prune CVS repository path from filename
	$filename =~ s|^$cvsdir/|| if $cvsdir;

	# Prune Attic directory from filename
	$filename =~ s|/Attic/|/|;

	# Prune leading '/' at the beginning of the path
	$filename =~ s|^/||;

	# Remove any spurious '//' sequences from CVS
	$filename =~ s|//|/|g;

	$self->{filename} = $filename;

	#
	# Extract old/new revisions
	#

	# Get major/minor revision numbers
	my ($r1, $r2);

	# Parse revision numbers such as 1.34 or 1.1.1.23
	if ($rev =~ /^(.*)\.([0-9]+)$/)
	{
		# Guess previous revision
		$self->{r1} = $1 . "." . ($2 - 1);
		$self->{r2} = $rev;
	}
	else
	{
		print STDERR "*** Warning: can't parse revision '$rev'\n";
	}

	if ($removed)
	{
		undef $self->{r2};
	}
	# Added?
	elsif ($rev =~ /1\.1$/)
	{
		undef $self->{r1};
	}

	return $self;
}

# Return normalized filename
sub filename { return shift->{filename}; }

# Return old file revision
sub r1 { return shift->{r1} || "NONE"; }

# Return new file revision
sub r2 { return shift->{r2} || "NONE"; }

# Return commit timestamp
sub date { return shift->{date}; }


#
# Handle a list of changed files, the associated log message and the author
#
package ChangeSet;

# Construct a new ChangeSet.  Arg1 is the author, arg2 is the log message
sub new($$$)
{
	my $class = shift;
	bless {
		author => shift,
		log => shift,
		files => [],
		date => "1970/01/01 00:00:00"
	}, $class;
}

# Add a new FileRev entry
sub add
{
	my ($self, $filerev) = @_;

	push @{$self->{files}}, $filerev;

	# Collect date of newest change
	$self->{date} = $filerev->{date} if ($self->{date} lt $filerev->{date} )
}

# Retrieve the author name
sub author { return shift->{author}; }

# Retrieve the log message
sub log { return shift->{log}; }

# Return an array of FileRev objects
sub files { return @{shift->{files}}; }


#
# Maintain a collection of ChangeSets sorted by authors and log messages
#
package CSList;

sub new($$$)
{
	my $class = shift;
	bless { authors => {} }, $class;
}

#
# Augment or add a ChangeSet to the collection with a new FilRev entry
#
sub add_filerev
{
	my ($self, $author, $log, $filerev) = @_;

	my ($changeset, $l);

	# Complain for missing log entries
	$log = "*** Empty log message! ***" if !$log;

	# Do we know this author yet?
	if (!($l = $self->{authors}{$author}))
	{
		main::log_output("Create new author $author");
		$l = $self->{authors}{$author} = {};
	}

	# Do we know this log yet?
	if (!($changeset = ${$l}{$log}))
	{
		main::log_output("Create new ChangeSet for $author", $log);
		$changeset = ChangeSet->new($author, $log); 
		${$l}{$log} = $changeset;
	}

	main::log_output("Append new file for $author on " . $filerev->filename
		. " rev " . $filerev->r1 . " -> " . $filerev->r2);
	$changeset->add($filerev);
}

#
# Construct a FileRev entry and add it with CSList::add_filerev()
#
sub add_file
{
	my ($self, $author, $log, $cvsdir, $file, $rev, $date, $removed) = @_;

	my $filerev = FileRev->new($cvsdir, $file, $rev, $date, $removed);
	$self->add_filerev($author, $log, $filerev);
}

#
# Return a list containing all author names
#
sub authors
{
	return keys %{shift->{authors}};
}

#
# Return a list containing all ChangeSet objects for a specified author
# the list is sorted in ascending date order
#
sub changesets
{
	my ($self, $author) = @_;

	return sort { $a->{date} cmp $b->{date} } values %{$self->{authors}{$author}};
}


#
# Main program
#
package main;


sub add_to_cc(\$$)
{
	my ($cc, $email) = @_;
	$$cc .= length($$cc) ? ", $email" : "$email" if($$cc !~ /$email/);
}

# include first file in second file
sub append_file($$)
{
	local $/; # enable localized slurp mode
	open(my $in,  '<', shift) or die $!;
	open(my $out, '>>', shift) or die $!;
	print {$out} <$in>;
}

# Create empty file with specified owner
sub create_empty_file($$$)
{
	my $filename = shift;

	open(FILE, ">$filename") or die $!;
	close FILE;

	if (my $user = shift)
	{
		my (undef,undef,$uid,$gid) = getpwnam($user) or die $!;
		chown $uid, $gid, $filename;

		if (my $mode = shift)
		{
			chmod $mode, $filename;
		}
	}
}

sub bugzillate($)
{
	return if !$opt_bugurl;

	$_[0] =~ s#\#(\d{2,6})#<a href='$opt_bugurl?id=$1'>\#$1</a>#g;
}

sub send_mail(\$\$$$$$)
{
	my ($text, $html, $module, $to, $cc, $author) = @_;

	# Avoid sending empty mails
	if (!$$text)
	{
		print STDERR "Not sending empty mail.\n" if $opt_verbose;
		return;
	}

	# Build subject line
	my $subject = "CVS commit";
	$subject .= " by $author" if ($author);
	$subject .= " log" if (!$author);
	$subject .= " for $module" if ($module);
	{
		# Compute current time
		my (undef , undef, undef, $mday, $mon, $year, undef, undef, undef) = localtime;
		$year += 1900;
		$mon += 1;
		$subject .= sprintf(" (%04d-%02d-%02d)", $year, $mon, $mday);
	}
	
	my $from;
	if ($author and $opt_maildomain)
	{
		$from = "$author <$author\@$opt_maildomain>";
	}
	else
	{
		$from = "CVS logger <$opt_sender>";
	}

	my $newsgroups = "";

	# Force recipient if set
	if ($opt_recipient)
	{
		$to = $opt_recipient;
	}

	# Strip "mailto:" (the default)
	if ($to =~ /^mailto:(.+)/)
	{
		$to = $1;
	}
	# Match newsgroups
	elsif ($to =~ /^news:(.+)/)
	{
		$newsgroups = $1;
		$to = "";
	}

	if ($opt_outfile)
	{
		print STDERR "Writing mail to '$opt_outfile'...\n" if $opt_verbose;
		open (MAIL, ">>$opt_outfile") or die "Couldn't open outfile: $!";
	}
	elsif ($newsgroups)
	{
		print STDERR "Posting article in '$newsgroups'...\n" if $opt_verbose;
		open (MAIL, "|/usr/bin/inews -h") or die "Couldn't exec inews: $!";
	}
	elsif ($to)
	{
		print STDERR "Sending mail to <$to>...\n" if $opt_verbose;
		open (MAIL, "|/usr/lib/sendmail -t") or die "Couldn't exec sendmail: $!";
	}
	else
	{
		print STDERR "No recipient, discarding mail.\n" if $opt_verbose;
		open (MAIL, ">/dev/null") or die "Couldn't open /dev/null: $!";
	}

	print MAIL "From: $from\n";
	print MAIL "To: $to\n" if ($to);
	print MAIL "Cc: $cc\n" if ($cc);
	print MAIL "Newsgroups: $newsgroups\n" if ($newsgroups);
	print MAIL "Subject: $subject\n";

	print MAIL <<EOF;
MIME-Version: 1.0
Content-Type: multipart/alternative;
  boundary="Boundary-00=_R+zZ+ucfVzM1q7w"

This is a multi-part message in MIME format.

--Boundary-00=_R+zZ+ucfVzM1q7w
Content-Type: text/plain;
  charset="iso-8859-1"
Content-Disposition: inline

$$text

--
Generated by Deluxe Loginfo $versiontag by Bernardo Innocenti <bernie\@develer.com>
http://www.codewiz.org/projects/index.html#loginfo

--Boundary-00=_R+zZ+ucfVzM1q7w
Content-Type: text/html;
  charset="iso-8859-1"

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>$subject</title>
</head>
<body text='#000000' bgcolor='#ffffff'>
<table border='0' cellspacing='0' cellpadding='5' width='100%' bgcolor='#eeeeee'>
$$html
</table>
<p>
--<br>
<small>Generated by <a href="http://www.codewiz.org/projects/index.html#loginfo">Deluxe Loginfo</a> $versiontag by Bernardo Innocenti &lt;bernie\@develer.com&gt;</small></p>
</body>
</html>
--Boundary-00=_R+zZ+ucfVzM1q7w--
EOF

	close(MAIL);

	# Clear buffers
	$$text = "";
	$$html = "";
}

sub dodiff($$$$)
{
	my ($module, $file, $r1, $r2) = @_;
	my $diff = "";
	my $cnt = 0;
	my $copts = "";

	# Avoid diffs for files added or removed from CVS
	#return "" if (($r1 eq "NONE") or ($r2 eq "NONE"));

	# Avoid diffs for files removed from CVS
	return "" if ($r2 eq "NONE");

	# Workaround for first revion of added files (does only work with rdiff!)
	$r1 = "1.0" if ($r1 eq "NONE");

	# Regex to match source files (doesn't work with cvs rdiff)
	#my $srcfile = '\.(cpp|cc|cxx|C|c\+\+|c|l|y|h|h|hh|hxx|hpp|h\+\+|pl|jsp|java|py|sh)$';
	#$copts = "dpbB" if ($file =~ /$srcfile/);

	my $cvsroot = $opt_cvsroot;
	$cvsroot .= "/$module" if $module;

	print STDERR "+ cvs -Qfn -d$cvsroot rdiff -kk -u$copts -r$r1 -r$r2 $file\n" if $opt_verbose;
	open(CVS, "-|") || exec 'cvs', '-Qfn', "-d$cvsroot", 'rdiff', '-kk', "-u$copts", "-r$r1", "-r$r2", $file;

	while(<CVS>)
	{
		next if /^Index:/;
		$cnt++;

		# Truncate diff when it exceeds <difflimit>
		# or if the size grows over <difflimit> full lines of 80 characters.
		if ($opt_difflimit and
			(($cnt > $opt_difflimit) or (length($diff) > $opt_difflimit * 80)))
		{
			# Limit exceeded: discard further input and exit
			$diff .= "*** SIZE LIMIT EXCEEDED - DIFF TRUNCATED ***\n";
			while (<CVS>) {}
			last;
		}
		$diff .= $_;
	}
	close(CVS);
	$diff .= "\n" if (length($diff));

	return $diff;
}

sub diff2html($)
{
	my $out = "<pre>\n";

	foreach (split /\n/, shift)
	{
		# Remove trailing \n
		chomp;

		# Replace HTML reserved chars with entities
		s/&/&amp;/g;
		s/</&lt;/g;
		s/>/&gt;/g;

		# Mark leading whitespace at EOL
		s/([^ ])(\s+)$/$1<span style="background-color: #FF0000">$2<\/span>/;

		# Mark hidden whitespace before TABs
		s/([^ ])( +)\t/$1<span style="background-color: #FF0000">$2<\/span>\t/;

		# Colorize Diff
		if (/^(--- |\+\+\+ |diff)/)
		{
			$out .= "<font color=\"#006600\">$_</font>\n";
		}
		elsif (/^\+/)
		{
			$out .= "<font color=\"#000088\">$_</font>\n";
		}
		elsif (/^-/)
		{
			$out .= "<font color=\"#880000\">$_</font>\n";
		}
		elsif (/^@@/)
		{
			$out .= "<font color=\"#997700\">$_</font>\n";
		}
		elsif (/^\*\*\*/)
		{
			$out .= "<font color=\"#FF0000\">$_</font>\n";
		}
		else
		{
			$out .= "$_\n";
		}
	}
	return $out;

### BEGIN: EXPERIMENTAL/UNUSED CODE ###
	# Fork
	my $pid = open (ENSCRIPT_OUTPUT, "-|");
	die ("can't fork") unless defined($pid);
	if (!$pid)
	{
		# In child: pass text diff to enscript and die
		open (ENSCRIPT_INPUT, "|-") || exec 'enscript', '--color', '-Whtml', '-Ediffu', '-o', '-', '-';
		print ENSCRIPT_INPUT shift;
		exit 0;
	}
	else
	{
		# In parent: collect enscript output
		my $out = "";
		while(<ENSCRIPT_OUTPUT>)
		{
			$out .= $_ if (/^<PRE>/ .. /<\/PRE>/)
		}
		return $out;
	}
### END: EXPERIMENTAL/UNUSED CODE ###
}

sub format_output($$$$$\$)
{
	my ($author, $text, $log, $module, $tagname, $ccrecipients) = @_;
	my ($fmtText, $fmtHtml, $cc);
	my $diff = "";

	log_output("Processing commit by $author", $text);

	# Do nothing for empty file lists
	if (length($text) == 0)
	{
		log_output("Skipping empty log entry");
		return ("", "");
	}

	if ($log =~ /CVS.?SILENT/)
	{
		# Ignore this commit and reset silent status
		log_output("Ignoring commit by $author because of CVSSILENT", $log);
		return ("", "");
	}

	foreach (split '\n', $log)
	{
		if (/^CCMAIL:\s*(.*)\s*$/)
		{
			add_to_cc($ccrecipients, $1);
		}
	}

	# sort the list of affected files to make it look cooler
	my @outlist = sort (split /^/, $text);

	$fmtHtml .= "<tr><td colspan='3' bgcolor='#dddddd'><font color='#bb2222'><strong>$author</strong></font>";
	$fmtHtml .= " <font color='#225522'><em>(on branch $tagname)</em></font>" if ($tagname ne "HEAD");
	$fmtHtml .= "</td></tr>\n";

	$fmtText .= "$author";
	$fmtText .= " (on branch $tagname)" if ($tagname ne "HEAD");
	$fmtText .= ":\n";

	$fmtText .= "$log\n";
	bugzillate($log);
	$fmtHtml .= "<tr><td colspan='3' bgcolor='#dddddd'><pre>$log</pre></td></tr>\n";

	foreach my $o (@outlist)
	{
		chop $o;
		my ($file, $r1, $r2) = split/\t/, $o;

		# Guess CVS operation from revisions pair
		my $state = 'M';
		$state = 'R' if ($r2 eq "NONE");
		$state = 'A' if ($r1 eq "NONE");

		# Find out a "good" revision to link to
		my $rev = $r2;
		$rev = $r1 if ($r2 eq "NONE");

		$fmtText .= sprintf("$state %6s  $file\n", $rev);

		my $statelink = $state;
		if ($opt_cvsurl)
		{
			# Prepend a slash to the module name if needed, define to an empty string otherwise
			my $module_path = "";
			$module_path = "/$module" if $module;

			if ($state eq 'M')
			{
				$statelink = "<a href=\"$opt_cvsurl$module_path/$file.diff?r1=text&tr1=$r1&r2=text&tr2=$r2&diff_format=h\">$state</a>";
			}
			elsif ($state eq 'A')
			{
				$statelink = "<a href=\"$opt_cvsurl$module_path/$file?rev=$r2&content-type=text/vnd.viewcvs-markup\">$state</a>";
			}
			elsif ($state eq 'R')
			{
				$statelink = "<a href=\"$opt_cvsurl$module_path/$file?rev=$r1&content-type=text/vnd.viewcvs-markup\">$state</a>";
			}
		}

		$diff .= dodiff($module, $file, $r1, $r2) if ($opt_diff);

		my $color = "";
		my $color_end = "";
		if ($state eq 'A') { $color = '<font color="#000088">' };
		if ($state eq 'R') { $color = '<font color="#880000">' };
		$color_end = "</font>" if $color;

		$fmtHtml .= "<tr><td width='1%'>$statelink</td><td width='1%'>$color$rev$color_end</td><td width='100%'>$color$file$color_end</td></tr>\n";
	}

	# Put some spacing between the file list and the diff
	$fmtText .= "\n";

	if (length($diff))
	{
		$fmtText .= $diff;
		$fmtText .= "\n";

		$fmtHtml .= "<tr><td colspan='3' bgcolor='#ffffff'>" . diff2html($diff) . "</td></tr>";
	}

	# Some spacing
	$fmtHtml .= "<tr><td colspan='3' bgcolor='#ffffff'><p>&nbsp;</p></td></tr>\n";

	return ($fmtText, $fmtHtml);
}

#
# Process accumulated logs
#
sub process_cslist($$$)
{
	my ($cslist, $module, $recipient) = @_;
	my $fmtText = "";
	my $fmtHtml = "";
	my $ccrecipients = "";
	my $tagname = "HEAD"; # FIXME

	foreach my $author ($cslist->authors)
	{
		foreach my $changeset ($cslist->changesets($author))
		{
			my $outtext = "";

			#DEBUG
			#use Dumpvalue;
			#my $dumper = new Dumpvalue;
			#print STDERR "****BEGIN ChangeSet ****\n";
			#$dumper->dumpValue($changeset);
			#print STDERR "**** END ChangeSet ****\n";

			foreach my $frev ($changeset->files)
			{
				#DEBUG
				#print STDERR "**** BEGIN FileRev ****\n";
				#$dumper->dumpValue($frev);
				#print STDERR "**** END FileRev ****\n";

				$outtext .= $frev->filename() . "\t" . $frev->r1() . "\t" . $frev->r2() . "\n";
			}

			my @out = format_output($author, $outtext, $changeset->{log}, $module, $tagname, $ccrecipients);
			$fmtText .= $out[0];
			$fmtHtml .= $out[1];
		}

		if ($opt_byauthor)
		{
			send_mail($fmtText, $fmtHtml, $module, $recipient, $ccrecipients, $author);

			# Reset accumulated output
			$fmtText = $fmtHtml = "";
			$ccrecipients = "";
		}
	}

	if (!$opt_byauthor)
	{
		send_mail($fmtText, $fmtHtml, $module, $recipient, $ccrecipients, undef);
	}
}


#
# Process commitlog files
#
sub dolog_commitlog($$)
{
	my ($module, $commitlog) = @_;

	# initialize with the default values
	my $tagname = "HEAD";
	my $juststarted = 1;
	my $beforelogmsg = 1;
	my $directory = "";
	my $author = "";
	my $relfile = "";
	my $r1 = "";
	my $r2 = "";
	my $logmessage = "";
	my $date = "1970/01/01 00:00:00";
	my $cslist = CSList->new();

	open COMMITLOG, "< $commitlog" or die "couldn't open '$commitlog': $!\n";

	while(<COMMITLOG>)
	{
		if ($juststarted)
		{
			next if /^\s*$/;
			$juststarted = 0;
			chop;
			if(/^(\S*) (.*)$/)
			{
				$directory = $1;
				$_ = $2;
			}

			# "directory - New Directory" ?
			# "directory - Import sources" ?
			if(/^- /) {
				#FIXME: $silentcommit = 1 if(/^- New/);
				next;
			}
			my @files = ();
			while(/^([^,]+,(?:NONE|[\d\.]+),(?:NONE|[\d\.]+)) ?(.*)/)
			{
				push @files, $1;
				$_ = $2;
			}
			foreach my $f (@files)
			{
				next if (!length($f));
				my $file;
				($file,$r1,$r2) = $f =~ /(.+),(.+),(.+)/;
				$relfile = "$directory/$file";
			}
		}
		elsif ($beforelogmsg)
		{
			next if (/^Update of /);
			next if (/^In directory /);

			if (/^Author: \s*(\S+)/)  { $author = $1;      }
			elsif (/^Date: \s*(.+)$/) { $date = $1;        }
			elsif (/^\s*Tag: (\S+)/)  { $tagname = $1;     }
			elsif (/^Log Message:/)   { $beforelogmsg = 0; }
		}
		else
		{
			if (/^---END---$/)
			{
				while (chomp $logmessage) {}

				# FIXME: relfile ?
				# FIXME: $r1/$r2 ?
				# FIXME: $date ?
				$cslist->add_file($author, $logmessage, "", $relfile, $r1, $date, $r2 eq "NONE");

				# Restart
				$directory = "";
				$relfile = "";
				$r1 = $r2 = "";
				$logmessage = "";
				$juststarted = 1;
				$beforelogmsg = 1;
				$date = "1970/01/01 00:00:00";
			}
			else
			{
				# Collect log message
				$logmessage .= $_;
			}
		}
	}

	close COMMITLOG;

	# Rotate log file
	if (!$opt_keeplogs)
	{
		my $oldlog = $commitlog;
		if ($commitlog =~ /^(.*)\.new$/)
		{
			$oldlog = $1;
		}
		else
		{
			$oldlog = "$commitlog.old";
		}

		append_file($commitlog, $oldlog);
		create_empty_file($commitlog, "cvs", 0660);
	}

	return $cslist;
}

#
# Process cvs rlog output
#
sub dolog_rlog($$)
{
	my ($module, $commitlog) = @_;
	my $stamp;

	#
	# Extract CVS directory prefix from CVSROOT string
	#
	my $cvsdir;

	if ($opt_cvsprefix)
	{
		$cvsdir = $opt_cvsprefix;
	}
	elsif ($opt_cvsroot and $opt_cvsroot =~ /^:[^:@]*:[^:@]*@[^:@]*:([^:@]+)$/)
	{
		$cvsdir = $1;
	}


	# Parser states:
	#  1 - parsing file header
	#  2 - parsing revision log
	#  3 - parsing revision message
	my $state = 1;

	# initialize vars with the default values
	my $file = "";
	my $rev = "";
	my $log = "";

	# A nested data structure to hold all collected log data
	my $cslist = CSList->new;

	my $tagname = "HEAD"; # FIXME: unused
	my $directory = "";
	my $date = "";
	my $author = "";
	my $outtext = "";
	my $removed = 0;

	if ($commitlog)
	{
		open RLOG, "< $commitlog" or die "couldn't open '$commitlog': $!\n";
	}
	else
	{
		# Compose CVSROOT if needed
		my $cvsroot = $opt_cvsroot;
		$cvsroot .= "/$module" if $module;

		if (! -d $opt_stampdir)
		{
			print STDERR "Creating $opt_stampdir since it doesn't exist\n";
			mkdir $opt_stampdir || die "Can't create $opt_stampdir: $!\n";
		}

		# Generate stamp file name from CVSROOT
		$stamp = $cvsroot;
		$stamp =~ tr|:\/\\@.|_____|;
		$stamp .= ".stamp";
		$stamp = "$opt_stampdir/$stamp";

		# Get timestamp from file, touch it and get filestamp again
		my $dates;
		$dates = `date --rfc-2822 -r $stamp`;
		chomp $dates;
		$dates = 'yesterday' if (!$dates);
		`touch $stamp.new`; # Update stamp file
		$dates .= "<";
		$dates .= `date --rfc-2822 -r $stamp.new`;
		chomp $dates;

		print STDERR "+ cvs -Qfn -d$cvsroot rlog -N -d '$dates' ''\n" if $opt_verbose;
		open(RLOG, "-|") || exec 'cvs', '-Qfn', "-d$cvsroot", 'rlog', '-N', "-d$dates", '';
	}

	while(<RLOG>)
	{
		if ($state == 1) # parse the header
		{
			if (/^RCS file: (.*)$/)
			{
				$file = $1;
			}
			elsif (/^---/)
			{
				$state = 2;
				$author = "UNKNOWN";
				$removed = 0;
			}
		}
		elsif ($state == 2) # parse revision log
		{
			if (/^revision (.*)/)
			{
				$rev = $1;
			}
			# EXAMPLE: date: 2003/11/26 19:46:57;  author: codewiz;  state: dead;  lines: +0 -0
			elsif (/^date: *([^;]*); *author: *([^;]*); *state:([^;]*);/)
			{
				$date = $1;
				$author = $2;
				$removed = ($3 =~ /dead/) ? 1 : 0;
				$state = 3;
			}
			elsif (/^===/)
			{
				$state = 1;
			}
		}
		elsif ($state == 3) # parse log message
		{
			if (/^---/ or /^===/)
			{
				$cslist->add_file($author, $log, $cvsdir, $file, $rev, $date, $removed);

				$log = "";
				$state = 2;
				$state = 1 if (/^===/);
			}
			else
			{
				# Append log line
				$log .= $_;
			}
		}
	} # end while(<>)

	close RLOG;
	die "Reading cvs rlog failed: $!" if $?;

	# Commit date for next log
	rename "$stamp.new", "$stamp" if ($stamp);

	return $cslist;
}

sub dolog($$$)
{
	my ($module, $commitlog, $recipient) = @_;
	my $cslist;

	if ($opt_verbose)
	{
		print STDERR "Processing changelog";
		print STDERR " from '$commitlog'" if $commitlog;
		print STDERR " on repository '$module'" if $module;
		print STDERR "...\n";
	}

	if ($opt_rlog)
	{
		$cslist = dolog_rlog($module, $commitlog);
	}
	else
	{
		$cslist = dolog_commitlog($module, $commitlog);
	}

	process_cslist($cslist, $module, $recipient);
}

#
# MAIN ENTRY POINT
#

# Make sure that CVS doesn't use "/root" as $HOME
delete $ENV{"HOME"};

# Use SSH by default with the :ext: protocol
$ENV{"CVS_RSH"} = "ssh";

GetOptions(
	'outfile=s'	=> \$opt_outfile,
	'keeplogs'	=> \$opt_keeplogs,
	'sender=s'	=> \$opt_sender,
	'recipient=s'	=> \$opt_recipient,
	'maildomain=s'	=> \$opt_maildomain,

	'module=s'	=> \$opt_module,
	'prjtab=s'	=> \$opt_prjtab,
	'rlog'		=> \$opt_rlog,
	'stampdir=s'	=> \$opt_stampdir,
	'by-author'	=> \$opt_byauthor,

	'cvsroot=s'	=> \$opt_cvsroot,
	'cvsprefix=s'	=> \$opt_cvsprefix,
	'cvsurl=s'	=> \$opt_cvsurl,
	'bugurl=s'	=> \$opt_bugurl,
	'diff'		=> \$opt_diff,
	'difflimit=n'	=> \$opt_difflimit,

	'verbose'	=> \$opt_verbose,
	'help'		=> sub { pod2usage(1); },
	'man'		=> sub { pod2usage(-exitstatus => 0, -verbose => 2); },
) or pod2usage(2);

if (($opt_prjtab || $opt_rlog) && @ARGV)
{
	print STDERR "ERROR: input file arguments are mutually exclusive with --rlog and --prjtab modes.\n";
	pod2usage(1);
}

if($opt_prjtab)
{
	print STDERR "Opening prjtab file: $opt_prjtab...\n" if $opt_verbose;
	open PRJTAB, $opt_prjtab or die "couldn't open $opt_prjtab: $!\n";

	while (<PRJTAB>)
	{
		# Skip comments and blank lines
		next if /^#/ or /^\s*$/;

		# NOTE: email hogs all remaining fields (\n must be chomped)
		my ($prjname, $cvsdir, $email) = split(' ', $_, 3);
		chomp $email;

		my $commitlog;
		$commitlog = "$cvsdir/commitlog.new" if !$opt_rlog;

		# Strip away CVS directory when using rlog
		$opt_cvsprefix=$cvsdir if ($opt_rlog);

		dolog($prjname, $commitlog, $email);
	}

	close PRJTAB;
}
elsif ($opt_rlog)
{
	if (!$opt_cvsroot)
	{
		print STDERR "ERROR: --rlog specified and no --cvsroot given.\n";
		pod2usage(1);
	}

	# Fetch from CVS
	dolog($opt_module, undef, $opt_recipient);
}
else
{
	if (!@ARGV)
	{
		print STDERR "ERROR: no log files provided as input.\n";
		pod2usage(1);
	}

	# Process command line arguments
	while(my $logfile = shift @ARGV)
	{
		dolog($opt_module, $logfile, $opt_recipient);
	}
}

__END__

=head1 NAME

deluxeloginfo - Process CVS commit logs to generate e-mail report with hyperlinks to ViewCVS and Bugzilla

=head1 SYNOPSIS

deluxeloginfo [options] [<file> ...]

 Options:
   --outfile=file      use <file> as output instead of sending mail
   --sender=addr       specify sender address for CVS logs
   --maildomain=dom    specify e-mail domain for committers (used for To:)
   --recipient=addr    specify e-mail recipient or newsgroups (news:foo.bar.baz)
   --newsgroups=groups post log to a specified newsgroups (comma separated).
   --by-author         send one mail for each committer (currently only for rlog mode)

   --module            CVS module to work on
   --prjtab=file       use <file> as a prjtab file to find CVS repositories
   --rlog              use cvs rlog output instead of loginfo files
   --stampdir          directory to store timestamps for cvs rlog dates
   --keeplogs          keep log files instead of rotating them

   --cvsroot=root      base CVSROOT for use with cvs -d option
   --cvsprefix=dir     Repository prefix to strip away in logs
   --cvsurl=url        set URL for ViewCVS viewcvs.cgi (default: none)
   --bugurl=url        set URL for Bugzilla's show_bug.cgi (default: none)
   --diff              show diff for commits (requires --cvsroot)
   --difflimit=n       show up to <n> lines of diff output

   --verbose           turn on verbose diagnostic output
   --help              brief help message
   --man               full documentation

=head1 USAGE

Add this line to your CVSROOT/loginfo

   ALL (echo %{sVv}; echo "Author: $USER"; cat ; echo "---END---") >> $CVSROOT/commitlog.new

Put something like this in your crontab:

   29 */6 * * * root /usr/local/bin/deluxeloginfo \
       --prjtab=/etc/projects/prjtab \
       --cvsurl="http://cvs.develer.com/viewcvs.cgi" \
       --bugurl="http://bugs.develer.com/show_bug.cgi"

If you have multiple CVS repositories, you can process all them at once
by setting up a project description file like this:
 
   #NAME	CVSROOT					RECIPIENTS
   kde		/cvs/kde				kde-devel@lists.kde.org
   gnome	/cvs/gnome				gnome-devel@lists.gnome.org
   uclinux	:ext:bernie@cvs.uclinux.org:/cvsroot	uclinux-dev@uclinux.org
   gcc		:pserver:bernie@gcc.gnu.org:/cvs/gcc	news:comp.lang.c++,gnu.misc.discuss

Multiple recipients can be specified separated by commas.
Prefix the address with "news:" to post to newsgroups.

=head1 AUTHOR

Written by Bernardo Innocenti <bernie@develer.com>. Contact me for
patch submissions and bug reports.

=cut

