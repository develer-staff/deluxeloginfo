#!/usr/bin/perl -w
#
# $Id$
# Copyright 2002, 2003, 2004 Bernardo Innocenti <bernie@develer.com>
#
# Dedicated to the memory of Gerry, an extraordinary engineer and
# a good friend.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Loosely based on KDE's loginfo.pl:
#   free of any copyright. Originally written by taj@kde.org with small changes
#   by coolo@kde.org and daniel.naber@t-online.de
#   Many improvements and fixes by dirk@kde.org
#
#
# $Log$
# Revision 2.63  2004/12/27 01:26:58  bernie
# Improve de-htmlification; Merge ASCII and text signatures.
#
# Revision 2.62  2004/12/27 01:06:01  bernie
# Also print CS index in text output.
#
# Revision 2.61  2004/12/27 00:32:04  bernie
# --noascii, --nohtml: New options.
#
# Revision 2.60  2004/12/26 22:36:39  bernie
# Reorder options parsing to match help; Kill doc for --newsgroups and fix doc for --recipient.
#
# Revision 2.59  2004/12/26 22:24:54  bernie
# Document options by category.
#
# Revision 2.58  2004/11/26 02:27:41  bernie
# Also consider CVS module to generate stamp file.
#
# Revision 2.57  2004/11/24 01:18:20  bernie
# Don't complain for missing ancestors of new files.
#
# Revision 2.56  2004/11/24 00:32:05  bernie
# Fix module handling for --rlog mode.
#
# Revision 2.55  2004/11/24 00:16:04  bernie
# Simplify/fix prjtab parsing.
#
# Revision 2.54  2004/11/24 00:12:56  bernie
# Fix documentation style to match GNU standards.
#
# Revision 2.53  2004/10/07 01:00:48  bernie
# Don't pass -N to cvs rlog in order to get branch tags; Fix regex for branch numbers.
#
# Revision 2.52  2004/10/07 00:03:35  bernie
# Cleanup and fix a bug with first revisions of branches.
#
# Revision 2.51  2004/10/06 23:08:08  bernie
# Scary support for branch names in --rlog mode.
#
# Revision 2.50  2004/10/05 01:21:04  bernie
# Add workaround for branch leaders.
#
# Revision 2.49  2004/08/09 18:36:18  bernie
# Remove a few FIXMEs.
#
# Revision 2.48  2004/07/20 22:22:43  bernie
# Don't rely on undef's to compare strings (barfs warnings with 'use strict').
#
# Revision 2.47  2004/07/20 21:50:56  bernie
# htmlize raw log lines for the incipit to avoid escaping <br> tags
# we inserted between the lines.
#
# Revision 2.46  2004/07/15 22:26:30  bernie
# htmlize(): REALLY fix it this time... and reindent for readability.
#
# Revision 2.45  2004/07/15 22:24:45  bernie
# htmlize(): Fix it to escape the argument and not a copy.
#
# Revision 2.44  2004/07/14 23:23:48  bernie
# Also HTMLize log messages.
#
# Revision 2.43  2004/07/14 23:05:46  bernie
# Optimize away redundant <font>..</font> elements;
# Various HTML fixes reported by W3C's validator.
#
# Revision 2.42  2004/07/13 23:18:26  bernie
# Rename --indexlines to --index-lines for consistency.
#
# Revision 2.41  2004/07/13 23:12:28  bernie
# Omit author name before logs with --by-author.
#
# Revision 2.40  2004/07/13 21:06:25  bernie
# Add --index and --indexlines
#
# Revision 2.39  2004/07/09 09:24:27  bernie
# Fix Bug # 426.
#

use strict;
use Getopt::Long;
use Pod::Usage;

my $versiontag = '$Revision$';
$versiontag =~ s/.*: (.*) .*/$1/;

# Command line options
my $opt_keeplogs;
my $opt_verbose;
my $opt_logfile = "";
my $opt_sender = "cvs\@develer.com";
my $opt_recipient = "";
my $opt_outfile = "";
my $opt_prjtab = "";
my $opt_rlog;
my $opt_stampdir = "/var/state/loginfo";
my $opt_byauthor;
my $opt_maildomain = "";
my $opt_cvsurl = "";
my $opt_bugurl = "";
my $opt_diff;
my $opt_html = 1;
my $opt_ascii = 1;
my $opt_encoding = 'iso-8859-1';
my $opt_difflimit = 0;
my $opt_cvsroot = "";
my $opt_cvsprefix = "";
my $opt_module = "";
my $opt_index = 999;
my $opt_indexlines = 1;


#
# Print a message (arg 1) followed by an optional multi-line preformatted block (arg 2)
#
sub log_output
{
	if ($opt_verbose)
	{
		my ($msg, $text) = @_;
		print STDERR "  $msg" . ($text ? ":" : "") . "\n";
		if ($text)
		{
			foreach (split '\n', $text) { print "    $_\n"; }
		}
	}
}

#
# Hold a file-revision pair
#
package FileRev;

sub new($$$$$$$)
{
	#
	# Collect arguments and create instance
	#
	my $class = shift;
	my $cvsdir = shift;
	my $filename = shift;
	my $self = {
		r1 => shift,
		r2 => shift,
		tag => shift,
		date => shift
	};
	bless $self, $class;

	#
	# Normalize filename
	#

	# Prune ,v suffix from filename
	$filename =~ s|,v$||;

	# Prune CVS repository path from filename
	$filename =~ s|^$cvsdir/|| if $cvsdir;

	# Prune Attic directory from filename
	$filename =~ s|/Attic/|/|;

	# Prune leading '/' at the beginning of the path
	$filename =~ s|^/||;

	# Remove any spurious '//' sequences from CVS
	$filename =~ s|//|/|g;

	$self->{filename} = $filename;

	#
	# Extract old/new revisions
	#

	return $self;
}

# Return normalized filename
sub filename { return shift->{filename}; }

# Return old file revision
sub r1 { return shift->{r1} || "NONE"; }

# Return new file revision
sub r2 { return shift->{r2} || "NONE"; }

# Return the branch tag for the file
sub tag { return shift->{tag} || "HEAD"; }

# Return commit timestamp
sub date { return shift->{date}; }


#
# Handle a list of changed files, the associated log message and the author
#
package ChangeSet;

# Construct a new ChangeSet.  Arg1 is the author, arg2 is the log message
sub new($$$)
{
	my $class = shift;
	bless {
		author => shift,
		log => shift,
		files => [],
		tag => "HEAD",
		date => "1970/01/01 00:00:00"
	}, $class;
}

# Add a new FileRev entry
sub add
{
	my ($self, $filerev) = @_;

	push @{$self->{files}}, $filerev;

	# Collect date of newest change
	$self->{date} = $filerev->{date} if ($self->{date} lt $filerev->{date} );

	# Collect tag - FIXME: only one tag
	$self->{tag} = $filerev->tag;
}

# Retrieve the author name
sub author { return shift->{author}; }

# Retrieve the log message
sub log { return shift->{log}; }

# Return the branch tag for the file
sub tag { return shift->{tag} || "HEAD"; }

# Return an array of FileRev objects - TODO: sort by file name?
sub files { return @{shift->{files}}; }


#
# Maintain a collection of ChangeSets sorted by authors and log messages.
#
package CSList;

sub new($$$)
{
	my $class = shift;
	bless { authors => {} }, $class;
}

#
# Add a new FileRev entry to an existing ChangeSet.
# If no ChangeSet exists for the given log, create a new one.
#
sub add_filerev
{
	my ($self, $author, $log, $filerev) = @_;

	my ($changeset, $l);

	# Complain for missing log entries
	$log = "*** Empty log message! ***" if !$log;

	# Do we know this author yet?
	if (!($l = $self->{authors}{$author}))
	{
		main::log_output("Create new author $author");
		$l = $self->{authors}{$author} = {};
	}

	# Do we know this log yet?
	if (!($changeset = ${$l}{$log}))
	{
		main::log_output("Create new ChangeSet for $author", $log);
		$changeset = ChangeSet->new($author, $log); 
		${$l}{$log} = $changeset;
	}

	main::log_output("Append new file for $author on " . $filerev->filename
		. " rev " . $filerev->r1 . " -> " . $filerev->r2);
	$changeset->add($filerev);
}

#
# Construct a FileRev entry and add it with CSList::add_filerev()
#
sub add_file
{
	my $self = shift;
	my $author = shift;
	my $log = shift;
	my $filerev = FileRev->new(@_);
	$self->add_filerev($author, $log, $filerev);
}

#
# Return a list containing all author names.
#
sub authors
{
	return keys %{shift->{authors}};
}

#
# Return a list containing all ChangeSet objects for a specified author
# the list is sorted in ascending date order.
#
sub changesets
{
	my ($self, $author) = @_;

	return sort { $a->{date} cmp $b->{date} } values %{$self->{authors}{$author}};
}


#
# Main program
#
package main;


sub add_to_cc(\$$)
{
	my ($cc, $email) = @_;
	$$cc .= length($$cc) ? ", $email" : "$email" if($$cc !~ /$email/);
}

# include first file in second file
sub append_file($$)
{
	local $/; # enable localized slurp mode
	open(my $in,  '<', shift) or die $!;
	open(my $out, '>>', shift) or die $!;
	print {$out} <$in>;
}

# Create empty file with specified owner
sub create_empty_file($$$)
{
	my $filename = shift;

	open(FILE, ">$filename") or die $!;
	close FILE;

	if (my $user = shift)
	{
		my (undef,undef,$uid,$gid) = getpwnam($user) or die $!;
		chown $uid, $gid, $filename;

		if (my $mode = shift)
		{
			chmod $mode, $filename;
		}
	}
}

sub bugzillate($)
{
	return unless $opt_bugurl;

	$_[0] =~ s{#\s*(\d{2,6})}{<a href='$opt_bugurl?id=$1'>#$1</a>}g;
}

#
# Print a multi-part MIME header
#
sub mime_header(*)
{
	my $fh = shift;
	print $fh <<EOF;
MIME-Version: 1.0
Content-Type: multipart/alternative;
  boundary="Boundary-00=_R+zZ+ucfVzM1q7w"

This is a multi-part message in MIME format.

EOF
}

#
# Print MIME part header
#
sub mime_part(*$)
{
	my $fh = shift;
	my $type = shift;

	print $fh <<EOF;
--Boundary-00=_R+zZ+ucfVzM1q7w
Content-Type: $type;
  charset="$opt_encoding"
Content-Disposition: inline

EOF
}

#
# Print MIME footer
#
sub mime_footer(*)
{
	my $fh = shift;
	print $fh <<EOF;
--Boundary-00=_R+zZ+ucfVzM1q7w--
EOF
}

#
# Print ASCII e-mail signature
#
sub signature(*$)
{
	my $fh = shift;
	my $toascii = shift;

	my $sig = <<EOF;

<p>--<br />
<small>Generated by <a href="http://www.codewiz.org/projects/index.html#loginfo">Deluxe Loginfo</a> $versiontag by Bernardo Innocenti &lt;bernie\@develer.com&gt;</small></p>
EOF

	unhtml($sig) if $toascii;
	print $fh $sig;
}

#
# Print HTML header
#
sub html_header(*$)
{
	my $fh = shift;
	my $title = shift;

	print $fh <<EOF;
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>$title</title>
</head>
<body text='#000000' bgcolor='#ffffff'>
EOF
}

#
# Print HTML footer
#
sub html_footer(*)
{
	my $fh = shift;

	print $fh <<EOF;
</body>
</html>
EOF
}

sub send_mail(\$\$\$$$$$)
{
	my ($text, $html, $summary, $module, $to, $cc, $author) = @_;

	# Avoid sending empty mails
	if (!$$text)
	{
		print STDERR "Not sending empty mail.\n" if $opt_verbose;
		return;
	}

	# Count the change sets in the summary
	my @foo = split /^/, $$summary;
	if (!defined($opt_index) || (($opt_index > 0) && @foo <= $opt_index))
	{
		$summary = "";
	}
	else
	{
		# Complete the summary
		$summary = "<h3>ChangeSet Index:</h3>\n<ul>\n" . $$summary . "</ul>\n";
		bugzillate $summary;
	}

	# Build subject line
	my $subject = "CVS commit";
	$subject .= " by $author" if ($author);
	$subject .= " log" if (!$author);
	$subject .= " for $module" if ($module);
	{
		# Compute current time
		my (undef , undef, undef, $mday, $mon, $year, undef, undef, undef) = localtime;
		$year += 1900;
		$mon += 1;
		$subject .= sprintf(" (%04d-%02d-%02d)", $year, $mon, $mday);
	}
	
	my $from;
	if ($author and $opt_maildomain)
	{
		$from = "$author <$author\@$opt_maildomain>";
	}
	else
	{
		$from = "CVS logger <$opt_sender>";
	}

	my $newsgroups = "";

	# Force recipient if set
	if ($opt_recipient)
	{
		$to = $opt_recipient;
	}

	# Strip "mailto:" (the default)
	if ($to =~ /^mailto:(.+)/)
	{
		$to = $1;
	}
	# Match newsgroups
	elsif ($to =~ /^news:(.+)/)
	{
		$newsgroups = $1;
		$to = "";
	}

	if ($opt_outfile)
	{
		print STDERR "Writing mail to '$opt_outfile'...\n" if $opt_verbose;
		open (MAIL, ">>$opt_outfile") or die "Couldn't open outfile: $!";
	}
	elsif ($newsgroups)
	{
		print STDERR "Posting article in '$newsgroups'...\n" if $opt_verbose;
		open (MAIL, "|/usr/bin/inews -h") or die "Couldn't exec inews: $!";
	}
	elsif ($to)
	{
		print STDERR "Sending mail to <$to>...\n" if $opt_verbose;
		open (MAIL, "|/usr/lib/sendmail -t") or die "Couldn't exec sendmail: $!";
	}
	else
	{
		print STDERR "No recipient, discarding mail.\n" if $opt_verbose;
		open (MAIL, ">/dev/null") or die "Couldn't open /dev/null: $!";
	}

	print MAIL "From: $from\n";
	print MAIL "To: $to\n" if ($to);
	print MAIL "Cc: $cc\n" if ($cc);
	print MAIL "Newsgroups: $newsgroups\n" if ($newsgroups);
	print MAIL "Subject: $subject\n";

	#
	# Our intention here is to generate a plain message when
	# no HTML output is present and a MIME multi-part message
	# when we have HTML output alone or along with ASCII output.
	#
	mime_header(*MAIL) if $opt_html;

	# End of mail headers
	print MAIL "\n";

	if ($opt_ascii && $opt_html)
	{
		mime_part(*MAIL, 'text/plain');
	}

	if ($opt_ascii)
	{
		print MAIL unhtml($summary);
		print MAIL $$text;
		signature(*MAIL, 1);
	}

	if ($opt_html)
	{
		mime_part(*MAIL, 'text/html');
		html_header(*MAIL, $subject);
		print MAIL $summary;
		print MAIL $$html;
		signature(*MAIL, 0);
		html_footer(*MAIL);
		mime_footer(*MAIL);
	}

	close(MAIL);

	# Clear buffers
	$$text = "";
	$$html = "";
}

sub dodiff($$$$)
{
	my ($module, $file, $r1, $r2) = @_;
	my $diff = "";
	my $cnt = 0;
	my $copts = "";

	# Avoid diffs for files added or removed from CVS
	#return "" if (($r1 eq "NONE") or ($r2 eq "NONE"));

	# Avoid diffs for files removed from CVS
	return "" if ($r2 eq "NONE");

	# Workaround for first revion of added files (does only work with rdiff!)
	$r1 = "1.0" if ($r1 eq "NONE");

	# Regex to match source files (doesn't work with cvs rdiff)
	#my $srcfile = '\.(cpp|cc|cxx|C|c\+\+|c|l|y|h|h|hh|hxx|hpp|h\+\+|pl|jsp|java|py|sh)$';
	#$copts = "dpbB" if ($file =~ /$srcfile/);

	# Prepend module name to file name
	$file = "$module/$file" if $module;

	print STDERR "+ cvs -Qfn -d$opt_cvsroot rdiff -kk -u$copts -r$r1 -r$r2 $file\n" if $opt_verbose;
	open(CVS, "-|") || exec 'cvs', '-Qfn', "-d$opt_cvsroot", 'rdiff', '-kk', "-u$copts", "-r$r1", "-r$r2", $file;

	while(<CVS>)
	{
		next if /^Index:/;
		$cnt++;

		# Truncate diff when it exceeds <difflimit>
		# or if the size grows over <difflimit> full lines of 80 characters.
		if ($opt_difflimit and
			(($cnt > $opt_difflimit) or (length($diff) > $opt_difflimit * 80)))
		{
			# Limit exceeded: discard further input and exit
			$diff .= "*** SIZE LIMIT EXCEEDED - DIFF TRUNCATED ***\n";
			while (<CVS>) {}
			last;
		}
		$diff .= $_;
	}
	close(CVS);
	$diff .= "\n" if length($diff);

	return $diff;
}

#
# Escape characters with special meaning for HTML in the passed string(s).
#
sub htmlize
{
	foreach (@_)
	{
		s/&/&amp;/g;
		s/</&lt;/g;
		s/>/&gt;/g;
	}
}

#
# Remove HTML tags from the passed string(s), trying to retain some formatting.
#
# Note: When called in void context, arguments are modified in-place,
#       otherwise unhtml() returns the translated strings.
#
sub unhtml
{
	my @copy;

	# Copy arguments if caller expects a result
	foreach (defined(wantarray) ? @copy = @_ : @_)
	{
		# Replace hyperlinks with plain-text versions
		s#<a\s+.*href=['"](.*?)['"](.*?)>(.*?)</a>#$3 [$1]#g;

		# Break paragraphs
		s#<br\s*/?>#\n#g;
		s#</p>#\n#g;

		# Remove all tags
		s#<(.*?)>##g;

		# Translate some commonly used entities
		s#&amp;#&#g;
		s#&lt;#<#g;
		s#&gt;#>#g;
	}

	return defined(wantarray) ? @copy : undef;
}

sub diff2html($)
{
	my ($newstyle, $oldstyle) = ("", "");
	my $out = "<pre>\n";

	foreach (split /\n/, shift)
	{
		# Remove trailing \n
		chomp;

		# Replace HTML reserved chars with entities
		htmlize $_;

		# Mark leading whitespace at EOL
		s/([^ ])(\s+)$/$1<span style="background-color: #FF0000">$2<\/span>/;

		# Mark hidden whitespace before TABs
		s/([^ ])( +)\t/$1<span style="background-color: #FF0000">$2<\/span>\t/;

		SWITCH: {
			/^(--- |\+\+\+ |diff)/ && do { $newstyle = "006600"; last SWITCH };
			/^\+/                  && do { $newstyle = "000088"; last SWITCH };
			/^-/                   && do { $newstyle = "880000"; last SWITCH };
			/^@@/                  && do { $newstyle = "997700"; last SWITCH };
			/^\*\*\*/              && do { $newstyle = "FF0000"; last SWITCH };
			$newstyle = "";
		}

		# Optimization: avoid printing redundant <font>...</font> pairs
		if ($newstyle ne $oldstyle)
		{
			$out .= "</font>" if ($oldstyle);
			$out .= "<font color='#$newstyle'>" if ($newstyle);
			$oldstyle = $newstyle;
		}

		$out .= "$_\n";
	}
	$out .= "</font>" if ($oldstyle);
	$out .= "</pre>\n";
	return $out;

### BEGIN: EXPERIMENTAL/UNUSED CODE ###
	# Fork
	my $pid = open (ENSCRIPT_OUTPUT, "-|");
	die ("can't fork") unless defined($pid);
	if (!$pid)
	{
		# In child: pass text diff to enscript and die
		open (ENSCRIPT_INPUT, "|-") || exec 'enscript', '--color', '-Whtml', '-Ediffu', '-o', '-', '-';
		print ENSCRIPT_INPUT shift;
		exit 0;
	}
	else
	{
		# In parent: collect enscript output
		my $out = "";
		while(<ENSCRIPT_OUTPUT>)
		{
			$out .= $_ if (/^<PRE>/ .. /<\/PRE>/)
		}
		return $out;
	}
### END: EXPERIMENTAL/UNUSED CODE ###
}

sub format_output($$$\$)
{
	my ($csnum, $changeset, $module, $ccrecipients) = @_;
	my ($fmtText, $fmtHtml, $summary);
	my $diff = "";
	my @files = $changeset->files;
	my $author = $changeset->author;
	my $log = $changeset->log;
	my $tagname = $changeset->tag;

	log_output("Processing ChangeSet by $author of " . scalar @files . " files.");

	# Do nothing for empty file lists
	if (@files == 0)
	{
		log_output("Skipping empty ChangeSet");
		return ("", "");
	}

	if ($log =~ /CVS.?SILENT/)
	{
		# Ignore this commit and reset silent status
		log_output("Ignoring commit by $author because of CVSSILENT", $log);
		return ("", "");
	}

	my $incipit = "";
	my $incipit_lines = 0;
	foreach (split '\n', $log)
	{
		if (/^CCMAIL:\s*(.*)\s*$/)
		{
			add_to_cc($ccrecipients, $1);
			next;
		}

		# Collect first lines
		if ($incipit_lines < $opt_indexlines)
		{
			$incipit .= '<br />' if $incipit;
			htmlize $_;
			$incipit .= $_;
		}
		elsif ($incipit_lines == $opt_indexlines and $opt_indexlines != 0)
		{
			$incipit .= '[...]';
		}
		$incipit_lines++;
	}

	$summary .= "<li><a href='#cs$csnum'>CS$csnum</a> - $incipit</li>\n";

	$fmtHtml .= "<a name='cs$csnum'></a>\n";
	$fmtHtml .= "<table border='0' cellspacing='0' cellpadding='5' width='100%' bgcolor='#eeeeee'>\n";
	unless ($opt_byauthor and $tagname eq "HEAD")
	{
		$fmtHtml .= "<tr><td colspan='3' bgcolor='#dddddd'>\n";
		unless ($opt_byauthor)
		{
			$fmtHtml .= " <font color='#bb2222'><strong>$author</strong></font>\n";
			$fmtText .= " *$author*";
		}
		unless ($tagname eq "HEAD")
		{
			$fmtHtml .= " <font color='#225522'><em>(on branch $tagname)</em></font>\n";
			$fmtText .= " (on branch $tagname)";
		}
		$fmtHtml .= "</td></tr>\n";
		$fmtText .= ":\n";
	}

	$fmtText .= "$log\n";
	htmlize $log;
	bugzillate $log;
	$fmtHtml .= "<tr><td colspan='3' bgcolor='#dddddd'><pre>$log</pre></td></tr>\n";

	foreach my $filerev (@files)
	{
		my $file = $filerev->filename();
		my $r1 = $filerev->r1();
		my $r2 = $filerev->r2();

		# Guess CVS operation from revisions pair
		my $state = 'M';
		$state = 'R' if ($r2 eq "NONE");
		$state = 'A' if ($r1 eq "NONE");

		# Find out a "good" revision to link to
		my $rev = $r2;
		$rev = $r1 if ($r2 eq "NONE");

		$fmtText .= sprintf("$state %6s  $file\n", $rev);

		my $statelink = $state;
		if ($opt_cvsurl)
		{
			# Prepend a slash to the module name if needed, define to an empty string otherwise
			my $module_path = "";
			$module_path = "/$module" if $module;

			if ($state eq 'M')
			{
				$statelink = "<a href=\"$opt_cvsurl$module_path/$file.diff?r1=text&amp;tr1=$r1&amp;r2=text&amp;tr2=$r2&amp;diff_format=h\">$state</a>";
			}
			elsif ($state eq 'A')
			{
				$statelink = "<a href=\"$opt_cvsurl$module_path/$file?rev=$r2&amp;content-type=text/vnd.viewcvs-markup\">$state</a>";
			}
			elsif ($state eq 'R')
			{
				$statelink = "<a href=\"$opt_cvsurl$module_path/$file?rev=$r1&amp;content-type=text/vnd.viewcvs-markup\">$state</a>";
			}
		}

		$diff .= dodiff($module, $file, $r1, $r2) if ($opt_diff);

		my $color = "";
		my $color_end = "";
		if ($state eq 'A') { $color = '<font color="#000088">' };
		if ($state eq 'R') { $color = '<font color="#880000">' };
		$color_end = "</font>" if $color;

		$fmtHtml .= "<tr><td width='1%'>$statelink</td><td width='1%'>$color$rev$color_end</td><td width='100%'>$color$file$color_end</td></tr>\n";
	}
	$fmtHtml .= "</table>\n";

	# Put some spacing between the file list and the diff
	$fmtText .= "\n";

	if (length($diff))
	{
		$fmtText .= $diff . "\n";
		$fmtHtml .= diff2html($diff);
	}

	# Some spacing
	$fmtHtml .= "<p>&nbsp;</p>\n";

	return ($fmtText, $fmtHtml, $summary);
}

#
# Process accumulated logs
#
sub process_cslist($$$)
{
	my ($cslist, $module, $recipient) = @_;
	my $fmtText = "";
	my $fmtHtml = "";
	my $summary = "";
	my $ccrecipients = "";
	my $csnum = 1;

	foreach my $author ($cslist->authors)
	{
		foreach my $changeset ($cslist->changesets($author))
		{
			my @out = format_output($csnum, $changeset, $module, $ccrecipients);
			$fmtText .= $out[0];
			$fmtHtml .= $out[1];
			$summary .= $out[2];
			$csnum++;
		}

		if ($opt_byauthor)
		{
			send_mail($fmtText, $fmtHtml, $summary, $module, $recipient, $ccrecipients, $author);

			# Reset accumulated output
			$fmtText = $fmtHtml = $summary = "";
			$ccrecipients = "";
			$csnum = 1;
		}
	}

	if (!$opt_byauthor)
	{
		send_mail($fmtText, $fmtHtml, $summary, $module, $recipient, $ccrecipients, undef);
	}
}

#
# Helper for dolog_rlog().
# Parse a CVS revision number and return the best guess for its ancestor.
#
sub guess_ancestor($)
{
	my ($rev) = @_;
	my $old;

	# New files don't have an ancestor
	return undef if $rev =~ /1\.1$/;

	# Parse revision numbers such as 1.34 or 1.7.2.42
	# Assign the radix (i.e.: 1.7.2) and the minor (i.e.: 42)
	if (my ($radix, $minor) = ($rev =~ /^([\d.]+)\.(\d+)$/))
	{
		# Guess the ancestor: usually one less than the new revision
		--$minor;
		$old = "$radix.$minor";

		# If the ancestor's minor revision was 0, perhaps we
		# were working with the first revision of a branch. 
		#
		# We can't just diff between version 1.9.2.0 and
		# 1.9.2.1, because the former doesn't exist and CVS
		# would diff against /dev/null.
		#
		# The correct ancestor in this example would be 1.9.
		#
		if ($minor <= 0)
		{
			($old) = ($radix =~ /^([\d.]+)\.\d+$/);
		}
	}

	unless (defined($old))
	{
		print STDERR "*** Warning: can't parse revision '$rev'\n";
	}

	return $old;
}

#
# Process commitlog files
#
sub dolog_commitlog($$)
{
	my ($module, $commitlog) = @_;

	# initialize with the default values
	my $tagname = "";
	my $juststarted = 1;
	my $beforelogmsg = 1;
	my $directory = "";
	my $author = "";
	my $logmessage = "";
	my $date = "1970/01/01 00:00:00";
	my @files = ();
	my $cslist = CSList->new();

	open COMMITLOG, "< $commitlog" or die "couldn't open '$commitlog': $!\n";

	while(<COMMITLOG>)
	{
		if ($juststarted)
		{
			next if /^\s*$/;
			$juststarted = 0;
			chop;
			if (/^(\S*) (.*)$/)
			{
				$directory = $1;
				$_ = $2;
			}

			# "directory - New Directory" ?
			# "directory - Import sources" ?
			next if /^- /;

			while (/^([^,]+,(?:NONE|[\d\.]+),(?:NONE|[\d\.]+)) ?(.*)/)
			{
				push @files, $1;
				$_ = $2;
			}
		}
		elsif ($beforelogmsg)
		{
			next if (/^Update of /);
			next if (/^In directory /);

			if (/^Author: \s*(\S+)/)  { $author = $1;      }
			elsif (/^Date: \s*(.+)$/) { $date = $1;        }
			elsif (/^\s*Tag: (\S+)/)  { $tagname = $1;     }
			elsif (/^Log Message:/)   { $beforelogmsg = 0; }
		}
		else
		{
			if (/^---END---$/)
			{
				while (chomp $logmessage) {}

				foreach my $f (@files)
				{
					next if (!length($f));
					my ($file, $r1, $r2) = $f =~ /(.+),(.+),(.+)/;
					my $relfile = "$directory/$file";
					$cslist->add_file($author, $logmessage, "", $relfile, $r1, $r2, $tagname, $date);
				}

				# Restart
				@files = ();
				$directory = "";
				$logmessage = "";
				$juststarted = 1;
				$beforelogmsg = 1;
				$tagname = "";
				$date = "1970/01/01 00:00:00";
			}
			else
			{
				# Collect log message
				$logmessage .= $_;
			}
		}
	}

	close COMMITLOG;

	# Rotate log file
	if (!$opt_keeplogs)
	{
		my $oldlog = $commitlog;
		if ($commitlog =~ /^(.*)\.new$/)
		{
			$oldlog = $1;
		}
		else
		{
			$oldlog = "$commitlog.old";
		}

		append_file($commitlog, $oldlog);
		create_empty_file($commitlog, "cvs", 0660);
	}

	return $cslist;
}

#
# Process cvs rlog output
#
sub dolog_rlog($$)
{
	my ($module, $commitlog) = @_;
	my $stamp;

	#
	# Extract CVS directory prefix from CVSROOT string
	#
	my $cvsdir;

	if ($opt_cvsprefix)
	{
		$cvsdir = $opt_cvsprefix;
	}
	elsif ($opt_cvsroot and $opt_cvsroot =~ /^:[^:@]*:[^:@]*@[^:@]*:([^:@]+)$/)
	{
		$cvsdir = $1;
	}

	if ($commitlog)
	{
		open RLOG, "< $commitlog" or die "couldn't open '$commitlog': $!\n";
	}
	else
	{
		if (! -d $opt_stampdir)
		{
			print STDERR "Creating $opt_stampdir since it doesn't exist\n";
			mkdir $opt_stampdir || die "Can't create $opt_stampdir: $!\n";
		}

		# Generate unique stamp file name from CVSROOT.
		$stamp = $opt_cvsroot;
		$stamp .= "/$module" if $module;
		$stamp =~ tr|:\/\\@.|_____|;
		$stamp .= ".stamp";
		$stamp = "$opt_stampdir/$stamp";

		# Get timestamp from file, touch it and get filestamp again
		my $dates;
		$dates = `date --rfc-2822 -r $stamp`;
		chomp $dates;
		$dates = 'yesterday' if (!$dates);
		`touch $stamp.new`; # Update stamp file
		$dates .= "<";
		$dates .= `date --rfc-2822 -r $stamp.new`;
		chomp $dates;

		# NOTE: $module may be an empty string, which is fine with CVS
		#       as it means "fetch the repository root".
		my @args = ('cvs', '-Qfn', "-d$opt_cvsroot", 'rlog', "-d$dates", "$module");
		print STDERR "+ " . join(' ', @args) . "\n" if $opt_verbose;
		open(RLOG, "-|") || exec @args;
	}

	# A nested data structure to hold all collected log data
	my $cslist = CSList->new;

	# initialize vars with the default values
	my $file = "";
	my $r2 = "";
	my $log = "";
	my $directory = "";
	my $date = "";
	my $author = "";
	my $outtext = "";
	my $removed = 0;
	my %rev_tags;

	# Parser states:
	#  1 - parsing file header
	#  2 - parsing revision log
	#  3 - parsing revision message
	my $state = 1;

	LOOP: while(<RLOG>)
	{
		if ($state == 1) # parse the header
		{
			if (/^RCS file: (.*)$/)
			{
				$file = $1;
				%rev_tags = ();
			}
			elsif (/^symbolic names:/)
			{
				# Collect list of branches and tags:
				#
				#   LONDON_DEMO: 1.23
				#   RELEASE_1_0: 1.14
				#   RELEASE_1_0_PATCHES: 1.23.0.6
				#
				while(<RLOG>)
				{
					# Extract the branch name and its revision
					if (my ($tag, $r) = /^\t(.*): (.*)$/)
					{
						my @rev = split(/\./, $r);

						# Revisions such as "1.27" are obviously not branches
						next if @rev <= 2;

						# Branch tags have the second last revision number
						# fixed to 0 (e.g.: 1.23.0.6)
						next unless ($rev[$#rev - 1] == 0);

						# Chop away the second last revision number
						@rev = @rev[0 .. ($#rev-2), $#rev];

						# Rebuild the branch revision (e.g.: 1.23.6)
						$r = join('.', @rev);

						# Create both a direct and reverse
						# mapping to retrieve branches.
						$rev_tags{$r} = $tag;
					}
					else
					{
						# bail out on end of tag list,
						# reprocessing last input as a valid keyword.
						redo LOOP;
					}
				}
			}
			elsif (/^---/)
			{
				$state = 2;
				$author = "UNKNOWN";
				$removed = 0;
			}
		}
		elsif ($state == 2) # parse revision log
		{
			# EXAMPLE: date: 2003/11/26 19:46:57;  author: codewiz;  state: dead;  lines: +0 -0
			if (/^date: *([^;]*); *author: *([^;]*); *state:([^;]*);/)
			{
				$date = $1;
				$author = $2;
				$removed = ($3 =~ /dead/) ? 1 : 0;
				$state = 3;
			}
			elsif (/^revision (.*)/)
			{
				# This is the new revision
				$r2 = $1;
			}
			elsif (/^===/)
			{
				$state = 1;
			}
		}
		elsif ($state == 3) # parse log message
		{
			# End of log message?
			if (/^---/ or /^===/)
			{
				# Compute old/new revision numbers
				my $r1 = guess_ancestor($r2);
				undef $r2 if $removed;

				# Try to match the file revision with a branch tag
				# Make sure we have a branch revision number
				# which is composed by at least 4 components.
				#
				# We throw away the minor revision number which
				# we don't need in order to match the branch number. 
				#
				my ($tagname, $r);
				$r = $r2 || $r1;
				if ((($r) = ($r =~ /^(\d+(?:.\d+){2,})\.\d+$/)))
				{
					$tagname = $rev_tags{$r} || "UNKNOWN";
				}

				$cslist->add_file($author, $log, $cvsdir, $file, $r1, $r2, $tagname, $date);

				$log = "";
				$state = 2;
				$state = 1 if /^===/;
			}
			else
			{
				# Append log line
				$log .= $_;
			}
		}
	} # end while(<>)

	close RLOG;
	die "Reading cvs rlog failed: $!" if $?;

	# Commit date for next log
	rename "$stamp.new", "$stamp" if ($stamp);

	return $cslist;
}

sub dolog($$$)
{
	my ($module, $commitlog, $recipient) = @_;
	my $cslist;

	if ($opt_verbose)
	{
		print STDERR "Processing changelog";
		print STDERR " from '$commitlog'" if $commitlog;
		print STDERR " on repository '$module'" if $module;
		print STDERR "...\n";
	}

	if ($opt_rlog)
	{
		$cslist = dolog_rlog($module, $commitlog);
	}
	else
	{
		$cslist = dolog_commitlog($module, $commitlog);
	}

	process_cslist($cslist, $module, $recipient);
}

#
# MAIN ENTRY POINT
#

# Make sure that CVS doesn't use "/root" as $HOME
delete $ENV{"HOME"};

# Use SSH by default with the :ext: protocol
$ENV{"CVS_RSH"} = "ssh";

GetOptions(
	'outfile=s'	=> \$opt_outfile,
	'sender=s'	=> \$opt_sender,
	'maildomain=s'	=> \$opt_maildomain,
	'recipient=s'	=> \$opt_recipient,

	'by-author'	=> \$opt_byauthor,
	'diff'		=> \$opt_diff,
	'difflimit=n'	=> \$opt_difflimit,
	'index:n'	=> \$opt_index,
	'index-lines:n'	=> \$opt_indexlines,
	'html!'         => \$opt_html,
	'ascii!'        => \$opt_ascii,

	'module=s'	=> \$opt_module,
	'prjtab=s'	=> \$opt_prjtab,
	'rlog'		=> \$opt_rlog,
	'stampdir=s'	=> \$opt_stampdir,
	'keeplogs'	=> \$opt_keeplogs,
	'cvsroot=s'	=> \$opt_cvsroot,
	'cvsprefix=s'	=> \$opt_cvsprefix,

	'cvsurl=s'	=> \$opt_cvsurl,
	'bugurl=s'	=> \$opt_bugurl,

	'verbose+'	=> \$opt_verbose,
	'help'		=> sub { pod2usage(1); },
	'man'		=> sub { pod2usage(-exitstatus => 0, -verbose => 2); },
) or pod2usage(2);

if (($opt_prjtab || $opt_rlog) && @ARGV)
{
	print STDERR "ERROR: input file arguments are mutually exclusive with --rlog and --prjtab modes.\n";
	pod2usage(1);
}

if ($opt_prjtab)
{
	print STDERR "Opening prjtab file: $opt_prjtab...\n" if $opt_verbose;
	open PRJTAB, $opt_prjtab or die "couldn't open $opt_prjtab: $!\n";

	while (<PRJTAB>)
	{
		chomp;

		# Skip comments and blank lines
		next if /^#/ or /^\s*$/;

		# NOTE: email hogs all remaining fields
		my ($prjname, $cvsdir, $email) = split(' ', $_, 3);

		my $commitlog;
		$commitlog = "$cvsdir/commitlog.new" if !$opt_rlog;

		# Strip away CVS directory when using rlog
		$opt_cvsprefix = $cvsdir if ($opt_rlog);

		dolog($prjname, $commitlog, $email);
	}

	close PRJTAB;
}
elsif ($opt_rlog)
{
	if (!$opt_cvsroot)
	{
		print STDERR "ERROR: --rlog specified and no --cvsroot given.\n";
		pod2usage(1);
	}

	# Fetch from CVS
	dolog($opt_module, undef, $opt_recipient);
}
else
{
	if (!@ARGV)
	{
		print STDERR "ERROR: no log files provided as input.\n";
		pod2usage(1);
	}

	# Process command line arguments
	while(my $logfile = shift @ARGV)
	{
		dolog($opt_module, $logfile, $opt_recipient);
	}
}

__END__

=head1 NAME

deluxeloginfo - Process CVS commit logs to generate e-mail report with hyperlinks to ViewCVS and Bugzilla

=head1 SYNOPSIS

deluxeloginfo [OPTION]... [FILE]...

 Options for output redirection:
   --outfile=FILE      use FILE as output instead of sending mail
   --sender=ADDR       sender address for CVS logs
   --maildomain=DOMAIN mail domain for committers (used for To:)
   --recipient=ADDR    comma-separated list of mail recipients or newsgroups
                       (devtools@lists.develer.com or news:comp.lang.c)

 Options for output format:
   --by-author         send one mail for each committer
   --diff              show diff for commits (requires --cvsroot)
   --difflimit=N       show up to N lines of diff output
   --index[=N]         output a summary of ChangeSets.  If N is specified,
                       the index is printed only when it contains at least N
		       ChangeSets. Set to 0 to always print the index
   --index-lines=N     Number of log lines in an index entry (default: 1)
   --noascii           Disable ASCII output
   --nohtml            Disable HTML output

 Options to specify the repository:
   --module=NAME       CVS module to work on
   --prjtab=FILE       use FILE as a prjtab file to find CVS repositories
   --rlog              use cvs rlog output instead of loginfo files
   --stampdir          where to store timestamps for cvs rlog
                       (default: /var/state/loginfo)
   --keeplogs          keep log files instead of rotating them
   --cvsroot=ROOT      base CVSROOT for use with cvs -d option
   --cvsprefix=DIR     Repository prefix to strip away in logs

 Options for web links:
   --cvsurl=URL        set URL for ViewCVS viewcvs.cgi (default: none)
   --bugurl=URL        set URL for Bugzilla's show_bug.cgi (default: none)

 Miscellaneous options:
   --verbose           turn on verbose diagnostic output
                       (specify twice to increase verbosity).
   --help              brief help message
   --man               full documentation

=head1 USAGE

Add this line to your CVSROOT/loginfo

   ALL (echo %{sVv}; echo "Author: $USER"; cat ; echo "---END---") >> $CVSROOT/commitlog.new

Put something like this in your crontab:

   29 */6 * * * root /usr/local/bin/deluxeloginfo \
       --prjtab=/etc/projects/prjtab \
       --cvsurl="http://cvs.develer.com/viewcvs.cgi" \
       --bugurl="http://bugs.develer.com/show_bug.cgi"

If you have multiple CVS repositories, you can process all them at once
by setting up a project description file like this:
 
   #NAME	CVSROOT					RECIPIENTS
   kde		/cvs/kde				kde-devel@lists.kde.org
   gnome	/cvs/gnome				gnome-devel@lists.gnome.org
   uclinux	:ext:bernie@cvs.uclinux.org:/cvsroot	uclinux-dev@uclinux.org
   gcc		:pserver:bernie@gcc.gnu.org:/cvs/gcc	news:comp.lang.c++,gnu.misc.discuss

Multiple recipients can be specified separated by commas.
Prefix the address list with "news:" to post to newsgroups.

=head1 AUTHOR

Written by Bernardo Innocenti <bernie@develer.com>. Contact me for
patch submissions and bug reports.

=cut

