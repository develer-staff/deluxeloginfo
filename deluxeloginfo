#!/usr/bin/perl -w
#
# $Id$
# Copyright (C) 2002,2003 by Bernardo Innocenti <bernie@develer.com>
#
# Dedicated to the memory of Gerry, an extraordinary engineer and
# a good friend.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Based on KDE's loginfo.pl:
#   free of any copyright. Originally written by taj@kde.org with small changes
#   by coolo@kde.org and daniel.naber@t-online.de
#   Many improvements and fixes by dirk@kde.org
#
#
# $Log$
# Revision 2.5  2003/12/05 00:07:54  bernie
# Avoid double slashes in ViewCVS URL generation.
#
# Revision 2.4  2003/11/27 23:54:14  bernie
# Tweak text output to look a little better.
#
# Revision 2.3  2003/11/26 22:15:59  bernie
# Handle removed files correctly in --rlog mode.
#
# Revision 2.2  2003/11/26 21:46:41  bernie
# Properly add MIME end boundary.
#
# Revision 2.1  2003/11/25 23:39:37  bernie
# Add Deluxe Loginfo home page.
#
# Revision 2.0  2003/11/25 23:35:16  bernie
# Bump revision to 2.0
#
# Revision 1.22  2003/11/16 07:32:05  bernie
# Safer stamp handling
#

use strict;
use Getopt::Long;
use Pod::Usage;

my $versiontag = '$Revision$';
$versiontag =~ s/.*: (.*) .*/$1/;

# Command line options
my $opt_keeplogs;
my $opt_verbose;
my $opt_logfile = "";
my $opt_sender = "cvs\@develer.com";
my $opt_recipient = "";
my $opt_outfile = "";
my $opt_prjtab = "";
my $opt_rlog;
my $opt_stampdir = "/var/state/loginfo";
my $opt_byauthor;
my $opt_maildomain = "";
my $opt_cvsurl = "";
my $opt_bugurl = "";
my $opt_diff;
my $opt_difflimit = 0;
my $opt_cvsroot = "";
my $opt_cvsprefix = "";
my $opt_module = "";


sub add_to_cc(\$$)
{
	my ($cc, $email) = @_;
	$$cc .= length($$cc) ? ", $email" : "\nCc: $email" if($$cc !~ /$email/);
}

# include first file in second file
sub append_file($$)
{
	local $/; # enable localized slurp mode
	open(my $in,  '<', shift) or die $!;
	open(my $out, '>>', shift) or die $!;
	print {$out} <$in>;
}

# Create empty file with specified owner
sub create_empty_file($$$)
{
	my $filename = shift;

	open(FILE, ">$filename") or die $!;
	close FILE;

	if (my $user = shift)
	{
		my (undef,undef,$uid,$gid) = getpwnam($user) or die $!;
		chown $uid, $gid, $filename;

		if (my $mode = shift)
		{
			chmod $mode, $filename;
		}
	}
}

sub bugzillate($)
{
	if ($opt_bugurl)
	{
		$_[0] =~ s#\#(\d{2,6})#<a href='$opt_bugurl?id=$1'>\#$1</a>#g;
	}
}

sub send_mail(\$\$$$$$)
{
	my ($text, $html, $module, $to, $cc, $author) = @_;

	# Avoid sending empty mails
	return if (!$$text);

	# Build subject line
	my $subject = "CVS commit";
	$subject .= " by $author" if ($author);
	$subject .= " log" if (!$author);
	$subject .= " for $module" if ($module);
	{
		# Compute current time
		my (undef , undef, undef, $mday, $mon, $year, undef, undef, undef) = localtime;
		$year += 1900;
		$mon += 1;
		$subject .= sprintf(" (%04d-%02d-%02d)", $year, $mon, $mday);
	}
	
	my $from;
	if ($author and $opt_maildomain)
	{
		$from = "$author <$author\@$opt_maildomain>";
	}
	else
	{
		$from = "CVS logger <$opt_sender>";
	}

	# Force recipient if set
	if ($opt_recipient)
	{
		$to = $opt_recipient;
		$cc = "";
	}

	if ($opt_outfile)
	{
		print STDERR "Writing mail to '$opt_outfile'...\n" if $opt_verbose;
		open (MAIL, ">>$opt_outfile") or die "Couldn't open outfile: $!";
	}
	else
	{
		print STDERR "Sending mail to <$to>...\n" if $opt_verbose;
		open (MAIL, "|/usr/lib/sendmail -t") or die "Couldn't open sendmail: $!";
	}

	print MAIL <<EOF;
From: $from
To: $to$cc
Subject: $subject
MIME-Version: 1.0
Content-Type: multipart/alternative;
  boundary="Boundary-00=_R+zZ+ucfVzM1q7w"

This is a multi-part message in MIME format.

--Boundary-00=_R+zZ+ucfVzM1q7w
Content-Type: text/plain;
  charset="UTF-8"
Content-Disposition: inline

$$text

--
Generated by Deluxe Loginfo $versiontag by Bernardo Innocenti <bernie\@develer.com>
http://www.codewiz.org/projects/index.html#loginfo

--Boundary-00=_R+zZ+ucfVzM1q7w
Content-Type: text/html;
  charset="UTF-8"

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>$subject</title>
</head>
<body text='#000000' bgcolor='#ffffff'>
<table border='0' cellspacing='0' cellpadding='5' width='100%' bgcolor='#eeeeee'>
$$html
</table>
<p>
--<br>
<small>Generated by <a href="http://www.codewiz.org/projects/index.html#loginfo">Deluxe Loginfo</a> $versiontag by Bernardo Innocenti &lt;bernie\@develer.com&gt;</small></p>
</body>
</html>
--Boundary-00=_R+zZ+ucfVzM1q7w--
EOF

	close(MAIL);

	# Clear buffers
	$$text = "";
	$$html = "";
}

sub dodiff($$$$)
{
	my ($module, $file, $r1, $r2) = @_;
	my $diff = "";
	my $cnt = 0;
	my $copts = "";

	# Avoid diffs for files added or removed from CVS
	return "" if (($r1 eq "NONE") or ($r2 eq "NONE"));

	# Regex to match source files
	#my $srcfile = '\.(cpp|cc|cxx|C|c\+\+|c|l|y|h|h|hh|hxx|hpp|h\+\+|pl|jsp|java|py|sh)';
	#$copts = "dpbB" if ($file =~ /$srcfile/);

	my $cvsroot = $opt_cvsroot;
	$cvsroot .= "/$module" if $module;

	print STDERR "+ cvs -Qfn -d$cvsroot rdiff -kk -u$copts -r$r1 -r$r2 $file\n" if $opt_verbose;
	open(CVS, "-|") || exec 'cvs', '-Qfn', "-d$cvsroot", 'rdiff', '-kk', "-u$copts", "-r$r1", "-r$r2", $file;

	while(<CVS>)
	{
		next if /^Index:/;
		if ($cnt++ > $opt_difflimit and $opt_difflimit)
		{
			# Limit exceeded: discard further input and exit
			$diff .= "*** SIZE LIMIT EXCEEDED - DIFF TRUNCATED ***\n";
			while (<CVS>) {}
			last;
		}
		$diff .= $_;
	}
	close(CVS);
	$diff .= "\n" if (length($diff));

	return $diff;
}

sub diff2html($)
{
	my $out = "<pre>\n";

	foreach (split /\n/, shift)
	{
		chomp;
		s/&/&amp;/g;
		s/</&lt;/g;
		s/>/&gt;/g;
		if (/^(---|\+\+\+|diff)/)
		{
			$out .= "<font color=\"#006600\">$_</font>\n";
		}
		elsif (/^\+/)
		{
			$out .= "<font color=\"#000088\">$_</font>\n";
		}
		elsif (/^-/)
		{
			$out .= "<font color=\"#880000\">$_</font>\n";
		}
		elsif (/^@@/)
		{
			$out .= "<font color=\"#997700\">$_</font>\n";
		}
		elsif (/^\*\*\*/)
		{
			$out .= "<font color=\"#FF0000\">$_</font>\n";
		}
		else
		{
			$out .= "$_\n";
		}
	}
	return $out;

	# Fork
	my $pid = open (ENSCRIPT_OUTPUT, "-|");
	die ("can't fork") unless defined($pid);
	if (!$pid)
	{
		# In child: pass text diff to enscript and die
		open (ENSCRIPT_INPUT, "|-") || exec 'enscript', '--color', '-Whtml', '-Ediffu', '-o', '-', '-';
		print ENSCRIPT_INPUT shift;
		exit 0;
	}
	else
	{
		# In parent: collect enscript output
		my $out = "";
		while(<ENSCRIPT_OUTPUT>)
		{
			$out .= $_ if (/^<PRE>/ .. /<\/PRE>/)
		}
		return $out;
	}
}

sub log_output($$)
{
	if ($opt_verbose)
	{
		my ($msg, $text) = @_;
		print STDERR "  $msg:\n";
		foreach (split '\n',$text) { print "    $_\n"; }
	}
}

sub format_output($$$$$)
{
	my ($committer, $text, $log, $module, $tagname) = @_;
	my ($fmtText, $fmtHtml);
	my $diff = "";

	log_output("Processing commit by $committer", $text);

	# Do nothing for empty file lists
	if (length($text) == 0)
	{
		print STDERR "    Skipping empty log entry.\n" if $opt_verbose;
		return ("", "");
	}

	# sort the list of affected files to make it look cooler
	my @outlist = sort (split /^/, $text);

	$fmtHtml .= "<tr><td colspan='3' bgcolor='#dddddd'><font color='#bb2222'><strong>$committer</strong></font>";
	$fmtHtml .= " <font color='#225522'><em>(on branch $tagname)</em></font>" if ($tagname ne "HEAD");
	$fmtHtml .= "</td></tr>\n";

	$fmtText .= "$committer";
	$fmtText .= " (on branch $tagname)" if ($tagname ne "HEAD");
	$fmtText .= ":\n";

	$fmtText .= "$log\n";
	bugzillate($log);
	$fmtHtml .= "<tr><td colspan='3' bgcolor='#dddddd'><pre>$log</pre></td></tr>\n";

	foreach my $o (@outlist)
	{
		chop $o;
		my ($file, $r1, $r2) = split/\t/, $o;

		# Guess CVS operation from revisions pair
		my $state = 'M';
		$state = 'R' if ($r2 eq "NONE");
		$state = 'A' if ($r1 eq "NONE");

		# Find out a "good" revision to link to
		my $rev = $r2;
		$rev = $r1 if ($r2 eq "NONE");

		$fmtText .= sprintf("$state %6s  $file\n", $rev);

		my $statelink = $state;
		if ($opt_cvsurl)
		{
			if($state eq 'M')
			{
				$statelink = "<a href=\"$opt_cvsurl/$module$file.diff?r1=text&tr1=$r1&r2=text&tr2=$r2&diff_format=h\">$state</a>";
			}
			elsif($state eq 'A')
			{
				$statelink = "<a href=\"$opt_cvsurl/$module$file?rev=$r2&content-type=text/vnd.viewcvs-markup\">$state</a>";
			}
			elsif($state eq 'R')
			{
				$statelink = "<a href=\"$opt_cvsurl/$module$file?rev=$r1&content-type=text/vnd.viewcvs-markup\">$state</a>";
			}
		}

		$diff .= dodiff($module, $file, $r1, $r2) if ($opt_diff);

		$fmtHtml .= "<tr><td>$statelink</td><td>$rev</td><td>$file</td></tr>\n";
	}

	# Put some spacing between the file list and the diff
	$fmtText .= "\n";

	if (length($diff))
	{
		$fmtText .= $diff;
		$fmtText .= "\n";

		$fmtHtml .= "<tr><td colspan='3' bgcolor='#ffffff'>" . diff2html($diff) . "</td></tr>";
	}

	# Some spacing
	$fmtHtml .= "<tr><td colspan='3' bgcolor='#ffffff'><p>&nbsp;</p></td></tr>\n";

	return ($fmtText, $fmtHtml);
}

#
# Process commitlog files
#
sub dolog_commitlog($$$)
{
	my ($module, $commitlog, $recipient) = @_;

	# initialize with the default values
	my $fmtText = "";
	my $fmtHtml = "";
	my $tagname = "HEAD";
	my $ccrecipients = "";
	my $juststarted = 1;
	my $beforelogmsg = 1;
	my $directory = "";
	my $author = "";
	my $outtext = "";
	my $logmessage = "";
	my $prev_author = "";
	my $prev_outtext = "";
	my $prev_logmessage = "";
	my $silentcommit = 0;

	open COMMITLOG, "< $commitlog" or die "couldn't open '$commitlog': $!\n";

	while(<COMMITLOG>)
	{
		if ($juststarted)
		{
			next if /^\s*$/;
			$juststarted = 0;
			chop;
			if(/^(\S*) (.*)$/)
			{
				$directory = $1;
				$_ = $2;
			}

			# "directory - New Directory" ?
			# "directory - Import sources" ?
			if(/^- /) {
				$silentcommit = 1 if(/^- New/);
				next;
			}
			my @files = ();
			while(/^([^,]+,(?:NONE|[\d\.]+),(?:NONE|[\d\.]+)) ?(.*)/)
			{
				push @files, $1;
				$_ = $2;
			}
			foreach my $f (@files)
			{
				next if (!length($f));
				my ($file,$r1,$r2) = $f =~ /(.+),(.+),(.+)/;
				my $relfile = "$directory/$file";
				$outtext .= "$relfile\t$r1\t$r2\n";
			}
		}
		elsif ($beforelogmsg)
		{
			next if (/^Update of /);
			next if (/^In directory /);

			if (/^Author: \s*(\S+)/) { $author = $1;      }
			elsif (/^\s*Tag: (\S+)/) { $tagname = $1;     }
			elsif (/^Log Message:/)  { $beforelogmsg = 0; }
		}
		else
		{
			add_to_cc($ccrecipients, $1) if (/^CCMAIL:\s*(.*)\s*$/);
			$silentcommit = 1 if (/CVS.?SILENT/);

			if (/^---END---$/)
			{
				while (chomp $logmessage) {}

				if ($silentcommit)
				{
					# Ignore this commit and reset silent status
					log_output("Ignoring commit by $author", $outtext);
					$silentcommit = 0;
				}
				elsif (($prev_logmessage eq $logmessage) && ($prev_author eq $author))
				{
					# Append current output to previous output
					log_output("Merging commit by $author", $outtext);
					$prev_outtext .= $outtext;
				}
				else
				{
					# Process previous output
					my @out = format_output($prev_author, $prev_outtext, $prev_logmessage, $module, $tagname);
					$fmtText .= $out[0];
					$fmtHtml .= $out[1];

					# Save current state for later
					$prev_author = $author;
					$prev_outtext = $outtext;
					$prev_logmessage = $logmessage;
				}

				# Restart
				$directory = "";
				$logmessage = "";
				$outtext = "";
				$juststarted = 1;
				$beforelogmsg = 1;
			}
			else
			{
				# Collect log message
				$logmessage .= "\t" . $_;
			}
		}
	}

	close COMMITLOG;

	# process last output set
	my @out = format_output($prev_author, $prev_outtext, $prev_logmessage, $module, $tagname);
	$fmtText .= $out[0];
	$fmtHtml .= $out[1];

	# Send mail
	send_mail($fmtText, $fmtHtml, $module, $recipient, $ccrecipients, undef);
}

#
# Process cvs rlog output
#
sub dolog_rlog($$$)
{
	my ($module, $commitlog, $recipient) = @_;
	my $stamp;

	# Parser states:
	#  1 - parsing file header
	#  2 - parsing revision log
	#  3 - parsing revision message
	my $state = 1;

	# initialize vars with the default values
	my $file = "";
	my $rev = "";
	my $log = "";

	# A nested data structure to hold all collected log data
	my %author_logs;

	my $fmtText = "";
	my $fmtHtml = "";
	my $tagname = "HEAD";
	my $ccrecipients = "";
	my $directory = "";
	my $author = "";
	my $outtext = "";
	my $silentcommit = 0; # TODO
	my $removed = 0;

	if ($commitlog)
	{
		open RLOG, "< $commitlog" or die "couldn't open '$commitlog': $!\n";
	}
	else
	{
		# Compose CVSROOT if needed
		my $cvsroot = $opt_cvsroot;
		$cvsroot .= "/$module" if $module;

		if (! -d $opt_stampdir)
		{
			print STDERR "Creating $opt_stampdir since it doesn't exist\n";
			mkdir $opt_stampdir || die "Can't create $opt_stampdir: $!\n";
		}

		# Generate stamp file name from CVSROOT
		$stamp = $cvsroot;
		$stamp =~ tr|:\/\\@.|_____|;
		$stamp .= ".stamp";
		$stamp = "$opt_stampdir/$stamp";

		# Get timestamp from file, touch it and get filestamp again
		my $dates;
		$dates = `date -r $stamp`;
		chomp $dates;
		$dates = 'yesterday' if (!$dates);
		`touch $stamp.new`; # Update stamp file
		$dates .= "<";
		$dates .= `date -r $stamp.new`;
		chomp $dates;

		print STDERR "+ cvs -Qfn -d$cvsroot rlog -N -d$dates .\n" if $opt_verbose;
		open(RLOG, "-|") || exec 'cvs', '-Qfn', "-d$cvsroot", 'rlog', '-N', "-d$dates", '.';
	}

	while(<RLOG>)
	{
		if ($state == 1) # parse the header
		{
			if (/^RCS file: (.*)$/)
			{
				$file = $1;
			}
			elsif (/^---/)
			{
				$state = 2;
				$author = "UNKNOWN";
				$removed = 0;
			}
		}
		elsif ($state == 2) # parse revision log
		{
			if (/^revision (.*)/)
			{
				$rev = $1;
			}
			# EXAMPLE: date: 2003/11/26 19:46:57;  author: codewiz;  state: dead;  lines: +0 -0
			elsif (/^date:[^;]*; *author: *([^;]*); *state:([^;]*);/)
			{
				$author = $1;
				$removed = ($2 =~ /dead/) ? 1 : 0;
				$state = 3;
			}
			elsif (/^===/)
			{
				$state = 1;
			}
		}
		elsif ($state == 3) # parse log message
		{
			if (/^---/ or /^===/)
			{
				$log = "*** Empty log message! ***" if !$log;
				
				if (my $l = $author_logs{$author})
				{
					if (my $f = ${$l}{$log})
					{
						print STDERR "  Append new file for $author on $file rev $rev:\n" if ($opt_verbose);

						# Append new file to existing log message
						push @$f, [ $file, $rev, $removed ];
					}
					else
					{
						if ($opt_verbose)
						{
							print STDERR "  Create new log for $author on $file rev $rev:\n";
							foreach (split '\n',$log) { print STDERR "    $_\n"; };
						}

						# Create new log message 
						${$l}{$log} = [ [ $file, $rev, $removed ] ];
					}
				}
				else
				{
					if ($opt_verbose)
					{
						print STDERR "  Create new author $author with $file rev $rev:\n";
						foreach (split '\n',$log) { print STDERR "    $_\n"; };
					}

					# Create new log message and append file/rev pair to it
					$author_logs{$author} = { $log => [ [ $file, $rev, $removed ] ] };
				}

				$log = "";
				$state = 2;
				$state = 1 if (/^===/);
			}
			else
			{
				# Append log line
				$log .= $_;
			}
		}
	} # end while(<>)

	close RLOG;

	# Commit date for next log
	rename "$stamp.new", "$stamp" if ($stamp);

	#
	# Extract CVS directory prefix from CVSROOT string
	#
	my $cvsdir;

	if ($opt_cvsprefix)
	{
		$cvsdir = $opt_cvsprefix;
	}
	elsif ($opt_cvsroot and $opt_cvsroot =~ /^:[^:@]*:[^:@]*@[^:@]*:([^:@]+)$/)
	{
		$cvsdir = $1;
	}

	#
	# Process accumulated logs
	#
	foreach my $author (keys %author_logs)
	{
		foreach my $log (keys %{$author_logs{$author}})
		{
			my $outtext = "";
			my $filelist = @{$author_logs{$author}}{$log};

			#DEBUG
			#use Dumpvalue;
			#my $dumper = new Dumpvalue;
			#print STDERR "****BEGIN filelist ****\n";
			#$dumper->dumpValue($filelist);
			#print STDERR "**** END filelist ****\n";

			foreach my $fileinfo (@$filelist)
			{
				#DEBUG
				#print STDERR "**** BEGIN fileinfo ****\n";
				#$dumper->dumpValue($fileinfo);
				#print STDERR "**** END fileinfo ****\n";

				my ($filename, $rev, $removed) = @$fileinfo;

				# Prune ,v suffix from filename
				$filename =~ s|,v$||;

				# Prune CVS repository path from filename
				$filename =~ s|^$cvsdir/|| if $cvsdir;

				# Prune Attic directory from filename
				$filename =~ s|/Attic/|/|;

				# Get major/minor revision numbers
				my ($r1, $r2);

				# Parse revision numbers such as 1.34 or 1.1.1.23
				if ($rev =~ /^(.*)\.([0-9]+)$/)
				{
					# Guess previous revision
					$r1 = $1 . "." . ($2 - 1);
					$r2 = $rev;
				}
				else
				{
					print STDERR "*** Warning: can't parse revision '$rev'\n";
					$r1 = "NONE";
					$r2 = "NONE";
				}

				if ($removed)
				{
					$r2 = "NONE";
				}
				# Added?
				elsif ($rev =~ /1\.1$/)
				{
					$r1 = "NONE";
				}

				$outtext .= "$filename\t$r1\t$r2\n";
			}

			my @out = format_output($author, $outtext, $log, $module, $tagname);
			$fmtText .= $out[0];
			$fmtHtml .= $out[1];

		}

		if ($opt_byauthor)
		{
			# Send mail
			send_mail($fmtText, $fmtHtml, $module, $recipient, $ccrecipients, $author);
			$fmtText = $fmtHtml = "";
		}
	}

	if (!$opt_byauthor)
	{
		# Send mail
		send_mail($fmtText, $fmtHtml, $module, $recipient, $ccrecipients, undef);
	}
}

sub dolog($$$)
{
	my ($module, $commitlog, $recipient) = @_;

	if ($opt_verbose)
	{
		print STDERR "Processing changelog";
		print STDERR " from '$commitlog'" if $commitlog;
		print STDERR " on repository '$module'" if $module;
		print STDERR "...\n";
	}

	if ($opt_rlog)
	{
		dolog_rlog($module, $commitlog, $recipient);
	}
	else
	{
		dolog_commitlog($module, $commitlog, $recipient);
	}
}

#
# MAIN ENTRY POINT
#

# Make sure that CVS doesn't use "/root" as $HOME
delete $ENV{"HOME"};

# Use SSH by default with the :ext: protocol
$ENV{"CVS_RSH"} = "ssh";

GetOptions(
	'outfile=s'	=> \$opt_outfile,
	'keeplogs'	=> \$opt_keeplogs,
	'sender=s'	=> \$opt_sender,
	'recipient=s'	=> \$opt_recipient,
	'maildomain=s'	=> \$opt_maildomain,

	'module=s'	=> \$opt_module,
	'prjtab=s'	=> \$opt_prjtab,
	'rlog'		=> \$opt_rlog,
	'stampdir=s'	=> \$opt_stampdir,
	'by-author'	=> \$opt_byauthor,

	'cvsroot=s'	=> \$opt_cvsroot,
	'cvsprefix=s'	=> \$opt_cvsprefix,
	'cvsurl=s'	=> \$opt_cvsurl,
	'bugurl=s'	=> \$opt_bugurl,
	'diff'		=> \$opt_diff,
	'difflimit=n'	=> \$opt_difflimit,

	'verbose'	=> \$opt_verbose,
	'help'		=> sub { pod2usage(1); },
	'man'		=> sub { pod2usage(-exitstatus => 0, -verbose => 2); },
) or pod2usage(2);

if($opt_prjtab)
{
	if (@ARGV)
	{
		print STDERR "ERROR: --prjtab and input file arguments are mutually exclusive.\n";
		pod2usage(1);
	}

	print STDERR "Opening prjtab file: $opt_prjtab...\n" if $opt_verbose;
	open PRJTAB, $opt_prjtab or die "couldn't open $opt_prjtab: $!\n";

	while (<PRJTAB>)
	{
		# Skip comments and blank lines
		next if /^#/ or /^\s*$/;

		# NOTE: email hogs all remaining fields (\n must be chomped)
		my ($prjname, $cvsdir, $email) = split(' ', $_, 3);
		chomp $email;

		my $commitlog = "$cvsdir/commitlog.new";

		dolog($prjname, $commitlog, $email);

		if (!$opt_keeplogs)
		{
			# Rotate log file
			append_file($commitlog, "$cvsdir/commitlog");
			create_empty_file($commitlog, "cvs", 0660);
		}
	}

	close PRJTAB;
}
elsif ($opt_rlog && $opt_cvsroot && !@ARGV)
{
	if (@ARGV)
	{
		print STDERR "ERROR: --rlog and input file arguments are mutually exclusive.\n";
		pod2usage(1);
	}

	# Fetch from CVS
	dolog($opt_module, undef, $opt_recipient);
}
else
{
	if (!@ARGV)
	{
		print STDERR "ERROR: no log files provided as input.\n";
		pod2usage(1);
	}

	# Process command line arguments
	while(my $logfile = shift @ARGV)
	{
		dolog($opt_module, $logfile, $opt_recipient);
	}
}

__END__

=head1 NAME

deluxeloginfo - Process CVS commit logs to generate e-mail report with hyperlinks to ViewCVS and Bugzilla

=head1 SYNOPSIS

deluxeloginfo [options] [<file> ...]

 Options:
   --outfile=file    use <file> as output instead of sending mail
   --sender=addr     specify sender address for CVS logs
   --maildomain=dom  specify e-mail domain for committers (used for To:)
   --recipient=addr  force email recipient (disables Cc: recipients too)
   --by-author       send one mail for each committer (currently only for rlog mode)

   --module          CVS module to work on
   --prjtab=file     use <file> as a prjtab file to find CVS repositories
   --rlog            use cvs rlog output instead of loginfo files
   --stampdir        directory to store timestamps for cvs rlog dates
   --keeplogs        keep log files instead of rotating them

   --cvsroot=root    base CVSROOT for use with cvs -d option
   --cvsprefix=dir   Repository prefix to strip away in logs
   --cvsurl=url      set URL for ViewCVS viewcvs.cgi (default: none)
   --bugurl=url      set URL for Bugzilla's show_bug.cgi (default: none)
   --diff            show diff for commits (requires --cvsroot)
   --difflimit=n     show up to <n> lines of diff output

   --verbose         turn on verbose diagnostic output
   --help            brief help message
   --man             full documentation

=head1 USAGE

Add this line to your CVSROOT/loginfo

   ALL (echo %{sVv}; echo "Author: $USER"; cat ; echo "---END---") >> $CVSROOT/commitlog.new

Put something like this in your crontab:

   29 */6 * * * root /usr/local/bin/deluxeloginfo \
       --prjtab=/etc/projects/prjtab \
       --cvsurl="http://cvs.develer.com/viewcvs.cgi" \
       --bugurl="http://bugs.develer.com/show_bug.cgi"

If you have multiple CVS repositories, you can process all them at once
by setting up a project description file like this:
 
   #name	CVSROOT		notify
   kde		/cvs/kde	kde-devel@lists.kde.org
   gnome	/cvs/gnome	gnome-devel@lists.gnome.org
   uclinux	/home/cvsroot   bernie@develer.com

=head1 AUTHOR

Written by Bernardo Innocenti <bernie@develer.com>. Contact me for
patch submissions and bug reports.

=cut

